//      This code was generated by Berp (http://https://github.com/gasparnagy/berp/).
//
//      Changes to this file may cause incorrect behavior and will be lost if
//      the code is regenerated.

use std::io::prelude::*;
use std::collections::VecDeque;
use std::fmt;
use std::default::Default;
use std::rc::Rc;
use std::sync::Arc;
use std::cell::RefCell;

use error::{Error, ErrorKind, Result, new_error};
use ast::Location;
use token::Token;
use gherkin_dialect::GherkinDialect;
use ast_builder::AstBuilder;
use token_matcher::TokenMatcher;
use token_scanner::TokenScanner;

#[derive(Debug, PartialEq, Eq, Hash, Clone, Copy)]
pub enum TokenType {
    None,
    Eof,
    Empty,
    Comment,
    TagLine,
    FeatureLine,
    BackgroundLine,
    ScenarioLine,
    ScenarioOutlineLine,
    ExamplesLine,
    StepLine,
    DocStringSeparator,
    TableRow,
    Language,
    Other,
}

impl fmt::Display for TokenType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}

#[derive(Debug, PartialEq, Eq, Hash, Clone, Copy)]
pub enum RuleType {
    None,
    Eof, // #EOF
    Empty, // #Empty
    Comment, // #Comment
    TagLine, // #TagLine
    FeatureLine, // #FeatureLine
    BackgroundLine, // #BackgroundLine
    ScenarioLine, // #ScenarioLine
    ScenarioOutlineLine, // #ScenarioOutlineLine
    ExamplesLine, // #ExamplesLine
    StepLine, // #StepLine
    DocStringSeparator, // #DocStringSeparator
    TableRow, // #TableRow
    Language, // #Language
    Other, // #Other
    GherkinDocument, // GherkinDocument! := Feature?
    Feature, // Feature! := Feature_Header Background? Scenario_Definition*
    FeatureHeader, // Feature_Header! := #Language? Tags? #FeatureLine Description_Helper
    Background, // Background! := #BackgroundLine Description_Helper Step*
    ScenarioDefinition, // Scenario_Definition! := Tags? (Scenario | ScenarioOutline)
    Scenario, // Scenario! := #ScenarioLine Description_Helper Step*
    ScenarioOutline, // ScenarioOutline! := #ScenarioOutlineLine Description_Helper Step* Examples_Definition*
    ExamplesDefinition, // Examples_Definition! [#Empty|#Comment|#TagLine-&gt;#ExamplesLine] := Tags? Examples
    Examples, // Examples! := #ExamplesLine Description_Helper Examples_Table?
    ExamplesTable, // Examples_Table! := #TableRow #TableRow*
    Step, // Step! := #StepLine Step_Arg?
    StepArg, // Step_Arg := (DataTable | DocString)
    DataTable, // DataTable! := #TableRow+
    DocString, // DocString! := #DocStringSeparator #Other* #DocStringSeparator
    Tags, // Tags! := #TagLine+
    DescriptionHelper, // Description_Helper := #Empty* Description? #Comment*
    Description, // Description! := #Other+
}

impl fmt::Display for RuleType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}

impl From<TokenType> for RuleType {
    fn from(token_type: TokenType) -> RuleType {
        match token_type {
            TokenType::Eof => RuleType::Eof,
            TokenType::Empty => RuleType::Empty,
            TokenType::Comment => RuleType::Comment,
            TokenType::TagLine => RuleType::TagLine,
            TokenType::FeatureLine => RuleType::FeatureLine,
            TokenType::BackgroundLine => RuleType::BackgroundLine,
            TokenType::ScenarioLine => RuleType::ScenarioLine,
            TokenType::ScenarioOutlineLine => RuleType::ScenarioOutlineLine,
            TokenType::ExamplesLine => RuleType::ExamplesLine,
            TokenType::StepLine => RuleType::StepLine,
            TokenType::DocStringSeparator => RuleType::DocStringSeparator,
            TokenType::TableRow => RuleType::TableRow,
            TokenType::Language => RuleType::Language,
            TokenType::Other => RuleType::Other,
            _ => RuleType::Other,
        }
    }
}

struct ParserContext<'a> {
    token_scanner: &'a mut TokenScan,
    token_matcher: &'a mut TokenMatch,
    token_queue: VecDeque<Rc<RefCell<Token>>>,
    errors: Vec<Error>,
}

pub struct Parser<B: Builder> {
    builder: B,
    pub stop_at_first_error: bool,
}

impl Default for Parser<AstBuilder> {
    fn default() -> Parser<AstBuilder> {
        Parser::with_builder(AstBuilder::default())
    }
}

impl<B: Builder> Parser<B> {
    pub fn with_builder(builder: B) -> Parser<B> {
        Parser {
            builder,
            stop_at_first_error: false,
        }
    }

    pub fn parse_str(&mut self, source: &str) -> Result<B::BuilderResult> {
        self.parse_reader(source.as_bytes())
    }

    pub fn parse_reader<R>(&mut self, source: R) -> Result<B::BuilderResult> where R: Read {
        self.parse_tokens(&mut TokenScanner::from(source))
    }

    pub fn parse_tokens<TS>(&mut self, token_scanner: &mut TS) -> Result<B::BuilderResult> where TS: TokenScan {
        self.parse_tokens_with_token_matcher(token_scanner, &mut TokenMatcher::default())
    }

    pub fn parse_str_with_token_matcher<TM>(&mut self, source: &str, token_matcher: &mut TM)
            -> Result<B::BuilderResult> where TM: TokenMatch {
        self.parse_reader_with_token_matcher(source.as_bytes(), token_matcher)
    }

    pub fn parse_reader_with_token_matcher<R, TM>(&mut self, source: R, token_matcher: &mut TM)
            -> Result<B::BuilderResult> where R: Read, TM: TokenMatch {
        self.parse_tokens_with_token_matcher(&mut TokenScanner::from(source), token_matcher)
    }

    pub fn parse_tokens_with_token_matcher<TS, TM>(&mut self, token_scanner: &mut TS, token_matcher: &mut TM)
            -> Result<B::BuilderResult> where TS: TokenScan, TM: TokenMatch {
        self.builder.reset();
        token_matcher.reset();

        let mut context = ParserContext {
                token_scanner,
                token_matcher,
                token_queue: VecDeque::new(),
                errors: Vec::new(),
        };

        self.start_rule(&mut context, RuleType::GherkinDocument)?;
        let mut state: u32 = 0;
        let mut token: Rc<RefCell<Token>>;
        loop {
            match self.read_token(&mut context) {
                Ok(t) => token = t,
                Err(error) => {
                    self.add_error(&mut context, error);
                    if self.stop_at_first_error {
                        break;
                    }
                    continue;
                },
            };
            state = self.match_token(state, token.clone(), &mut context)?;

            if token.borrow().is_eof() {
                break;
            }
        }

        self.end_rule(&mut context, RuleType::GherkinDocument)?;

        if !context.errors.is_empty() {
            Err(ErrorKind::Composite(context.errors))?;
        }

        Ok(self.builder.get_result())
    }

    fn add_error(&mut self, context: &mut ParserContext, error: Error) {
        context.errors.push(error);
//        if (context.errors.size() > 10)
//            throw new ParserException.CompositeParserException(context.errors);
    }

    fn handle_ast_result(&mut self, context: &mut ParserContext, result: Result<()>) -> Result<()> {
        self.handle_external_result(context, result, ())
    }

    #[allow(unused)] // until the function is implemented
    fn handle_external_result<V>(&mut self, _context: &mut ParserContext, result: Result<V>, _default_value: V)
            -> Result<V> {

        if self.stop_at_first_error {
            return result;
        }

        match result {
            Ok(value) => Ok(value),
            Err(_error) => {
                unimplemented!();
//                match error.kind() {
//                    &ErrorKind::Composite(errors) => {
//                        for parse_error in errors.into_iter() {
//                            self.add_error(context, parse_error);
//                        }
//                    },
//                    _ => self.add_error(context, error),
//                }
            },
        }

//        Ok(default_value)
    }

    fn build(&mut self, context: &mut ParserContext, token: Rc<RefCell<Token>>) -> Result<()> {
        let result = self.builder.build(token);
        self.handle_ast_result(context, result)
    }

    fn start_rule(&mut self, context: &mut ParserContext, rule_type: RuleType) -> Result<()> {
        let result = self.builder.start_rule(rule_type);
        self.handle_ast_result(context, result)
    }

    fn end_rule(&mut self, context: &mut ParserContext, rule_type: RuleType) -> Result<()> {
        let result = self.builder.end_rule(rule_type);
        self.handle_ast_result(context, result)
    }

    fn read_token(&mut self, context: &mut ParserContext) -> Result<Rc<RefCell<Token>>> {
        match context.token_queue.pop_front() {
            Some(token) => Ok(token),
            None => context.token_scanner.scan_next_token().map(|token| Rc::new(RefCell::new(token))),
        }
    }

    fn match_eof(&mut self, context: &mut ParserContext, token: &mut Token) -> Result<bool> {
        let result = context.token_matcher.match_eof(token);
        self.handle_external_result(context, result, false)
    }

    fn match_empty(&mut self, context: &mut ParserContext, token: &mut Token) -> Result<bool> {
        if token.is_eof() {return Ok(false)};
        let result = context.token_matcher.match_empty(token);
        self.handle_external_result(context, result, false)
    }

    fn match_comment(&mut self, context: &mut ParserContext, token: &mut Token) -> Result<bool> {
        if token.is_eof() {return Ok(false)};
        let result = context.token_matcher.match_comment(token);
        self.handle_external_result(context, result, false)
    }

    fn match_tag_line(&mut self, context: &mut ParserContext, token: &mut Token) -> Result<bool> {
        if token.is_eof() {return Ok(false)};
        let result = context.token_matcher.match_tag_line(token);
        self.handle_external_result(context, result, false)
    }

    fn match_feature_line(&mut self, context: &mut ParserContext, token: &mut Token) -> Result<bool> {
        if token.is_eof() {return Ok(false)};
        let result = context.token_matcher.match_feature_line(token);
        self.handle_external_result(context, result, false)
    }

    fn match_background_line(&mut self, context: &mut ParserContext, token: &mut Token) -> Result<bool> {
        if token.is_eof() {return Ok(false)};
        let result = context.token_matcher.match_background_line(token);
        self.handle_external_result(context, result, false)
    }

    fn match_scenario_line(&mut self, context: &mut ParserContext, token: &mut Token) -> Result<bool> {
        if token.is_eof() {return Ok(false)};
        let result = context.token_matcher.match_scenario_line(token);
        self.handle_external_result(context, result, false)
    }

    fn match_scenario_outline_line(&mut self, context: &mut ParserContext, token: &mut Token) -> Result<bool> {
        if token.is_eof() {return Ok(false)};
        let result = context.token_matcher.match_scenario_outline_line(token);
        self.handle_external_result(context, result, false)
    }

    fn match_examples_line(&mut self, context: &mut ParserContext, token: &mut Token) -> Result<bool> {
        if token.is_eof() {return Ok(false)};
        let result = context.token_matcher.match_examples_line(token);
        self.handle_external_result(context, result, false)
    }

    fn match_step_line(&mut self, context: &mut ParserContext, token: &mut Token) -> Result<bool> {
        if token.is_eof() {return Ok(false)};
        let result = context.token_matcher.match_step_line(token);
        self.handle_external_result(context, result, false)
    }

    fn match_doc_string_separator(&mut self, context: &mut ParserContext, token: &mut Token) -> Result<bool> {
        if token.is_eof() {return Ok(false)};
        let result = context.token_matcher.match_doc_string_separator(token);
        self.handle_external_result(context, result, false)
    }

    fn match_table_row(&mut self, context: &mut ParserContext, token: &mut Token) -> Result<bool> {
        if token.is_eof() {return Ok(false)};
        let result = context.token_matcher.match_table_row(token);
        self.handle_external_result(context, result, false)
    }

    fn match_language(&mut self, context: &mut ParserContext, token: &mut Token) -> Result<bool> {
        if token.is_eof() {return Ok(false)};
        let result = context.token_matcher.match_language(token);
        self.handle_external_result(context, result, false)
    }

    fn match_other(&mut self, context: &mut ParserContext, token: &mut Token) -> Result<bool> {
        if token.is_eof() {return Ok(false)};
        let result = context.token_matcher.match_other(token);
        self.handle_external_result(context, result, false)
    }

    fn match_token(&mut self, state: u32, token: Rc<RefCell<Token>>, context: &mut ParserContext) -> Result<u32> {
        match state {
            0 => self.match_token_at_0(token, context),
            1 => self.match_token_at_1(token, context),
            2 => self.match_token_at_2(token, context),
            3 => self.match_token_at_3(token, context),
            4 => self.match_token_at_4(token, context),
            5 => self.match_token_at_5(token, context),
            6 => self.match_token_at_6(token, context),
            7 => self.match_token_at_7(token, context),
            8 => self.match_token_at_8(token, context),
            9 => self.match_token_at_9(token, context),
            10 => self.match_token_at_10(token, context),
            11 => self.match_token_at_11(token, context),
            12 => self.match_token_at_12(token, context),
            13 => self.match_token_at_13(token, context),
            14 => self.match_token_at_14(token, context),
            15 => self.match_token_at_15(token, context),
            16 => self.match_token_at_16(token, context),
            17 => self.match_token_at_17(token, context),
            18 => self.match_token_at_18(token, context),
            19 => self.match_token_at_19(token, context),
            20 => self.match_token_at_20(token, context),
            21 => self.match_token_at_21(token, context),
            22 => self.match_token_at_22(token, context),
            23 => self.match_token_at_23(token, context),
            24 => self.match_token_at_24(token, context),
            25 => self.match_token_at_25(token, context),
            26 => self.match_token_at_26(token, context),
            28 => self.match_token_at_28(token, context),
            29 => self.match_token_at_29(token, context),
            30 => self.match_token_at_30(token, context),
            31 => self.match_token_at_31(token, context),
            32 => self.match_token_at_32(token, context),
            33 => self.match_token_at_33(token, context),
            _ => panic!("Unknown state: {}", state),
        }
    }

    // Start
    fn match_token_at_0(&mut self, token: Rc<RefCell<Token>>, context: &mut ParserContext) -> Result<u32> {
        if self.match_eof(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(27);
        }
        if self.match_language(context, &mut *token.borrow_mut())? {
            self.start_rule(context, RuleType::Feature)?;
            self.start_rule(context, RuleType::FeatureHeader)?;
            self.build(context, token)?;
            return Ok(1);
        }
        if self.match_tag_line(context, &mut *token.borrow_mut())? {
            self.start_rule(context, RuleType::Feature)?;
            self.start_rule(context, RuleType::FeatureHeader)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(2);
        }
        if self.match_feature_line(context, &mut *token.borrow_mut())? {
            self.start_rule(context, RuleType::Feature)?;
            self.start_rule(context, RuleType::FeatureHeader)?;
            self.build(context, token)?;
            return Ok(3);
        }
        if self.match_comment(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(0);
        }
        if self.match_empty(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(0);
        }

        let state_comment = String::from("State: 0 - Start");
        token.borrow().detach();
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#Language"),
            String::from("#TagLine"),
            String::from("#FeatureLine"),
            String::from("#Comment"),
            String::from("#Empty"),
        ];

        let token = token.borrow();
        let error = if token.is_eof() {
            let location = token.location;
            let expected = expected_tokens.join(", ");
            let message = format!("unexpected end of file, expected: {}", expected);

            ErrorKind::UnexpectedEof {
                location,
                message,
                state_comment,
//                expected_tokens,
            }
        } else {
            let token_location = token.location.expect("token location");
            let location = if token_location.get_column() > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.get_line();
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };
            let received = token.get_token_value().trim();
            let expected = expected_tokens.join(", ");
            let message = format!("({}:{}): expected: {}, got '{}'",
                    location.get_line(), location.get_column(), expected, received);

            ErrorKind::UnexpectedToken {
                location,
                message,
                state_comment,
//                received_token: *token,
//                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error.into());
        }

        self.add_error(context, new_error(error));
        Ok(0)
    }

    // GherkinDocument:0>Feature:0>Feature_Header:0>#Language:0
    fn match_token_at_1(&mut self, token: Rc<RefCell<Token>>, context: &mut ParserContext) -> Result<u32> {
        if self.match_tag_line(context, &mut *token.borrow_mut())? {
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(2);
        }
        if self.match_feature_line(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(3);
        }
        if self.match_comment(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(1);
        }
        if self.match_empty(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(1);
        }

        let state_comment = String::from("State: 1 - GherkinDocument:0>Feature:0>Feature_Header:0>#Language:0");
        token.borrow().detach();
        let expected_tokens: Vec<String> = vec![
            String::from("#TagLine"),
            String::from("#FeatureLine"),
            String::from("#Comment"),
            String::from("#Empty"),
        ];

        let token = token.borrow();
        let error = if token.is_eof() {
            let location = token.location;
            let expected = expected_tokens.join(", ");
            let message = format!("unexpected end of file, expected: {}", expected);

            ErrorKind::UnexpectedEof {
                location,
                message,
                state_comment,
//                expected_tokens,
            }
        } else {
            let token_location = token.location.expect("token location");
            let location = if token_location.get_column() > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.get_line();
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };
            let received = token.get_token_value().trim();
            let expected = expected_tokens.join(", ");
            let message = format!("({}:{}): expected: {}, got '{}'",
                    location.get_line(), location.get_column(), expected, received);

            ErrorKind::UnexpectedToken {
                location,
                message,
                state_comment,
//                received_token: *token,
//                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error.into());
        }

        self.add_error(context, new_error(error));
        Ok(1)
    }

    // GherkinDocument:0>Feature:0>Feature_Header:1>Tags:0>#TagLine:0
    fn match_token_at_2(&mut self, token: Rc<RefCell<Token>>, context: &mut ParserContext) -> Result<u32> {
        if self.match_tag_line(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(2);
        }
        if self.match_feature_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(3);
        }
        if self.match_comment(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(2);
        }
        if self.match_empty(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(2);
        }

        let state_comment = String::from("State: 2 - GherkinDocument:0>Feature:0>Feature_Header:1>Tags:0>#TagLine:0");
        token.borrow().detach();
        let expected_tokens: Vec<String> = vec![
            String::from("#TagLine"),
            String::from("#FeatureLine"),
            String::from("#Comment"),
            String::from("#Empty"),
        ];

        let token = token.borrow();
        let error = if token.is_eof() {
            let location = token.location;
            let expected = expected_tokens.join(", ");
            let message = format!("unexpected end of file, expected: {}", expected);

            ErrorKind::UnexpectedEof {
                location,
                message,
                state_comment,
//                expected_tokens,
            }
        } else {
            let token_location = token.location.expect("token location");
            let location = if token_location.get_column() > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.get_line();
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };
            let received = token.get_token_value().trim();
            let expected = expected_tokens.join(", ");
            let message = format!("({}:{}): expected: {}, got '{}'",
                    location.get_line(), location.get_column(), expected, received);

            ErrorKind::UnexpectedToken {
                location,
                message,
                state_comment,
//                received_token: *token,
//                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error.into());
        }

        self.add_error(context, new_error(error));
        Ok(2)
    }

    // GherkinDocument:0>Feature:0>Feature_Header:2>#FeatureLine:0
    fn match_token_at_3(&mut self, token: Rc<RefCell<Token>>, context: &mut ParserContext) -> Result<u32> {
        if self.match_eof(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::FeatureHeader)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(27);
        }
        if self.match_empty(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(3);
        }
        if self.match_comment(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(5);
        }
        if self.match_background_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::FeatureHeader)?;
            self.start_rule(context, RuleType::Background)?;
            self.build(context, token)?;
            return Ok(6);
        }
        if self.match_tag_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::FeatureHeader)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_scenario_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::FeatureHeader)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_scenario_outline_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::FeatureHeader)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioOutline)?;
            self.build(context, token)?;
            return Ok(17);
        }
        if self.match_other(context, &mut *token.borrow_mut())? {
            self.start_rule(context, RuleType::Description)?;
            self.build(context, token)?;
            return Ok(4);
        }

        let state_comment = String::from("State: 3 - GherkinDocument:0>Feature:0>Feature_Header:2>#FeatureLine:0");
        token.borrow().detach();
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#Empty"),
            String::from("#Comment"),
            String::from("#BackgroundLine"),
            String::from("#TagLine"),
            String::from("#ScenarioLine"),
            String::from("#ScenarioOutlineLine"),
            String::from("#Other"),
        ];

        let token = token.borrow();
        let error = if token.is_eof() {
            let location = token.location;
            let expected = expected_tokens.join(", ");
            let message = format!("unexpected end of file, expected: {}", expected);

            ErrorKind::UnexpectedEof {
                location,
                message,
                state_comment,
//                expected_tokens,
            }
        } else {
            let token_location = token.location.expect("token location");
            let location = if token_location.get_column() > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.get_line();
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };
            let received = token.get_token_value().trim();
            let expected = expected_tokens.join(", ");
            let message = format!("({}:{}): expected: {}, got '{}'",
                    location.get_line(), location.get_column(), expected, received);

            ErrorKind::UnexpectedToken {
                location,
                message,
                state_comment,
//                received_token: *token,
//                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error.into());
        }

        self.add_error(context, new_error(error));
        Ok(3)
    }

    // GherkinDocument:0>Feature:0>Feature_Header:3>Description_Helper:1>Description:0>#Other:0
    fn match_token_at_4(&mut self, token: Rc<RefCell<Token>>, context: &mut ParserContext) -> Result<u32> {
        if self.match_eof(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::FeatureHeader)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(27);
        }
        if self.match_comment(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Description)?;
            self.build(context, token)?;
            return Ok(5);
        }
        if self.match_background_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::FeatureHeader)?;
            self.start_rule(context, RuleType::Background)?;
            self.build(context, token)?;
            return Ok(6);
        }
        if self.match_tag_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::FeatureHeader)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_scenario_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::FeatureHeader)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_scenario_outline_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::FeatureHeader)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioOutline)?;
            self.build(context, token)?;
            return Ok(17);
        }
        if self.match_other(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(4);
        }

        let state_comment = String::from("State: 4 - GherkinDocument:0>Feature:0>Feature_Header:3>Description_Helper:1>Description:0>#Other:0");
        token.borrow().detach();
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#Comment"),
            String::from("#BackgroundLine"),
            String::from("#TagLine"),
            String::from("#ScenarioLine"),
            String::from("#ScenarioOutlineLine"),
            String::from("#Other"),
        ];

        let token = token.borrow();
        let error = if token.is_eof() {
            let location = token.location;
            let expected = expected_tokens.join(", ");
            let message = format!("unexpected end of file, expected: {}", expected);

            ErrorKind::UnexpectedEof {
                location,
                message,
                state_comment,
//                expected_tokens,
            }
        } else {
            let token_location = token.location.expect("token location");
            let location = if token_location.get_column() > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.get_line();
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };
            let received = token.get_token_value().trim();
            let expected = expected_tokens.join(", ");
            let message = format!("({}:{}): expected: {}, got '{}'",
                    location.get_line(), location.get_column(), expected, received);

            ErrorKind::UnexpectedToken {
                location,
                message,
                state_comment,
//                received_token: *token,
//                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error.into());
        }

        self.add_error(context, new_error(error));
        Ok(4)
    }

    // GherkinDocument:0>Feature:0>Feature_Header:3>Description_Helper:2>#Comment:0
    fn match_token_at_5(&mut self, token: Rc<RefCell<Token>>, context: &mut ParserContext) -> Result<u32> {
        if self.match_eof(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::FeatureHeader)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(27);
        }
        if self.match_comment(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(5);
        }
        if self.match_background_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::FeatureHeader)?;
            self.start_rule(context, RuleType::Background)?;
            self.build(context, token)?;
            return Ok(6);
        }
        if self.match_tag_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::FeatureHeader)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_scenario_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::FeatureHeader)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_scenario_outline_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::FeatureHeader)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioOutline)?;
            self.build(context, token)?;
            return Ok(17);
        }
        if self.match_empty(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(5);
        }

        let state_comment = String::from("State: 5 - GherkinDocument:0>Feature:0>Feature_Header:3>Description_Helper:2>#Comment:0");
        token.borrow().detach();
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#Comment"),
            String::from("#BackgroundLine"),
            String::from("#TagLine"),
            String::from("#ScenarioLine"),
            String::from("#ScenarioOutlineLine"),
            String::from("#Empty"),
        ];

        let token = token.borrow();
        let error = if token.is_eof() {
            let location = token.location;
            let expected = expected_tokens.join(", ");
            let message = format!("unexpected end of file, expected: {}", expected);

            ErrorKind::UnexpectedEof {
                location,
                message,
                state_comment,
//                expected_tokens,
            }
        } else {
            let token_location = token.location.expect("token location");
            let location = if token_location.get_column() > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.get_line();
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };
            let received = token.get_token_value().trim();
            let expected = expected_tokens.join(", ");
            let message = format!("({}:{}): expected: {}, got '{}'",
                    location.get_line(), location.get_column(), expected, received);

            ErrorKind::UnexpectedToken {
                location,
                message,
                state_comment,
//                received_token: *token,
//                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error.into());
        }

        self.add_error(context, new_error(error));
        Ok(5)
    }

    // GherkinDocument:0>Feature:1>Background:0>#BackgroundLine:0
    fn match_token_at_6(&mut self, token: Rc<RefCell<Token>>, context: &mut ParserContext) -> Result<u32> {
        if self.match_eof(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Background)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(27);
        }
        if self.match_empty(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(6);
        }
        if self.match_comment(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(8);
        }
        if self.match_step_line(context, &mut *token.borrow_mut())? {
            self.start_rule(context, RuleType::Step)?;
            self.build(context, token)?;
            return Ok(9);
        }
        if self.match_tag_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_scenario_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_scenario_outline_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioOutline)?;
            self.build(context, token)?;
            return Ok(17);
        }
        if self.match_other(context, &mut *token.borrow_mut())? {
            self.start_rule(context, RuleType::Description)?;
            self.build(context, token)?;
            return Ok(7);
        }

        let state_comment = String::from("State: 6 - GherkinDocument:0>Feature:1>Background:0>#BackgroundLine:0");
        token.borrow().detach();
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#Empty"),
            String::from("#Comment"),
            String::from("#StepLine"),
            String::from("#TagLine"),
            String::from("#ScenarioLine"),
            String::from("#ScenarioOutlineLine"),
            String::from("#Other"),
        ];

        let token = token.borrow();
        let error = if token.is_eof() {
            let location = token.location;
            let expected = expected_tokens.join(", ");
            let message = format!("unexpected end of file, expected: {}", expected);

            ErrorKind::UnexpectedEof {
                location,
                message,
                state_comment,
//                expected_tokens,
            }
        } else {
            let token_location = token.location.expect("token location");
            let location = if token_location.get_column() > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.get_line();
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };
            let received = token.get_token_value().trim();
            let expected = expected_tokens.join(", ");
            let message = format!("({}:{}): expected: {}, got '{}'",
                    location.get_line(), location.get_column(), expected, received);

            ErrorKind::UnexpectedToken {
                location,
                message,
                state_comment,
//                received_token: *token,
//                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error.into());
        }

        self.add_error(context, new_error(error));
        Ok(6)
    }

    // GherkinDocument:0>Feature:1>Background:1>Description_Helper:1>Description:0>#Other:0
    fn match_token_at_7(&mut self, token: Rc<RefCell<Token>>, context: &mut ParserContext) -> Result<u32> {
        if self.match_eof(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::Background)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(27);
        }
        if self.match_comment(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Description)?;
            self.build(context, token)?;
            return Ok(8);
        }
        if self.match_step_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Description)?;
            self.start_rule(context, RuleType::Step)?;
            self.build(context, token)?;
            return Ok(9);
        }
        if self.match_tag_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_scenario_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_scenario_outline_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioOutline)?;
            self.build(context, token)?;
            return Ok(17);
        }
        if self.match_other(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(7);
        }

        let state_comment = String::from("State: 7 - GherkinDocument:0>Feature:1>Background:1>Description_Helper:1>Description:0>#Other:0");
        token.borrow().detach();
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#Comment"),
            String::from("#StepLine"),
            String::from("#TagLine"),
            String::from("#ScenarioLine"),
            String::from("#ScenarioOutlineLine"),
            String::from("#Other"),
        ];

        let token = token.borrow();
        let error = if token.is_eof() {
            let location = token.location;
            let expected = expected_tokens.join(", ");
            let message = format!("unexpected end of file, expected: {}", expected);

            ErrorKind::UnexpectedEof {
                location,
                message,
                state_comment,
//                expected_tokens,
            }
        } else {
            let token_location = token.location.expect("token location");
            let location = if token_location.get_column() > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.get_line();
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };
            let received = token.get_token_value().trim();
            let expected = expected_tokens.join(", ");
            let message = format!("({}:{}): expected: {}, got '{}'",
                    location.get_line(), location.get_column(), expected, received);

            ErrorKind::UnexpectedToken {
                location,
                message,
                state_comment,
//                received_token: *token,
//                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error.into());
        }

        self.add_error(context, new_error(error));
        Ok(7)
    }

    // GherkinDocument:0>Feature:1>Background:1>Description_Helper:2>#Comment:0
    fn match_token_at_8(&mut self, token: Rc<RefCell<Token>>, context: &mut ParserContext) -> Result<u32> {
        if self.match_eof(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Background)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(27);
        }
        if self.match_comment(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(8);
        }
        if self.match_step_line(context, &mut *token.borrow_mut())? {
            self.start_rule(context, RuleType::Step)?;
            self.build(context, token)?;
            return Ok(9);
        }
        if self.match_tag_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_scenario_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_scenario_outline_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioOutline)?;
            self.build(context, token)?;
            return Ok(17);
        }
        if self.match_empty(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(8);
        }

        let state_comment = String::from("State: 8 - GherkinDocument:0>Feature:1>Background:1>Description_Helper:2>#Comment:0");
        token.borrow().detach();
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#Comment"),
            String::from("#StepLine"),
            String::from("#TagLine"),
            String::from("#ScenarioLine"),
            String::from("#ScenarioOutlineLine"),
            String::from("#Empty"),
        ];

        let token = token.borrow();
        let error = if token.is_eof() {
            let location = token.location;
            let expected = expected_tokens.join(", ");
            let message = format!("unexpected end of file, expected: {}", expected);

            ErrorKind::UnexpectedEof {
                location,
                message,
                state_comment,
//                expected_tokens,
            }
        } else {
            let token_location = token.location.expect("token location");
            let location = if token_location.get_column() > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.get_line();
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };
            let received = token.get_token_value().trim();
            let expected = expected_tokens.join(", ");
            let message = format!("({}:{}): expected: {}, got '{}'",
                    location.get_line(), location.get_column(), expected, received);

            ErrorKind::UnexpectedToken {
                location,
                message,
                state_comment,
//                received_token: *token,
//                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error.into());
        }

        self.add_error(context, new_error(error));
        Ok(8)
    }

    // GherkinDocument:0>Feature:1>Background:2>Step:0>#StepLine:0
    fn match_token_at_9(&mut self, token: Rc<RefCell<Token>>, context: &mut ParserContext) -> Result<u32> {
        if self.match_eof(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Background)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(27);
        }
        if self.match_table_row(context, &mut *token.borrow_mut())? {
            self.start_rule(context, RuleType::DataTable)?;
            self.build(context, token)?;
            return Ok(10);
        }
        if self.match_doc_string_separator(context, &mut *token.borrow_mut())? {
            self.start_rule(context, RuleType::DocString)?;
            self.build(context, token)?;
            return Ok(32);
        }
        if self.match_step_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Step)?;
            self.start_rule(context, RuleType::Step)?;
            self.build(context, token)?;
            return Ok(9);
        }
        if self.match_tag_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_scenario_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_scenario_outline_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioOutline)?;
            self.build(context, token)?;
            return Ok(17);
        }
        if self.match_comment(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(9);
        }
        if self.match_empty(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(9);
        }

        let state_comment = String::from("State: 9 - GherkinDocument:0>Feature:1>Background:2>Step:0>#StepLine:0");
        token.borrow().detach();
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#TableRow"),
            String::from("#DocStringSeparator"),
            String::from("#StepLine"),
            String::from("#TagLine"),
            String::from("#ScenarioLine"),
            String::from("#ScenarioOutlineLine"),
            String::from("#Comment"),
            String::from("#Empty"),
        ];

        let token = token.borrow();
        let error = if token.is_eof() {
            let location = token.location;
            let expected = expected_tokens.join(", ");
            let message = format!("unexpected end of file, expected: {}", expected);

            ErrorKind::UnexpectedEof {
                location,
                message,
                state_comment,
//                expected_tokens,
            }
        } else {
            let token_location = token.location.expect("token location");
            let location = if token_location.get_column() > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.get_line();
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };
            let received = token.get_token_value().trim();
            let expected = expected_tokens.join(", ");
            let message = format!("({}:{}): expected: {}, got '{}'",
                    location.get_line(), location.get_column(), expected, received);

            ErrorKind::UnexpectedToken {
                location,
                message,
                state_comment,
//                received_token: *token,
//                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error.into());
        }

        self.add_error(context, new_error(error));
        Ok(9)
    }

    // GherkinDocument:0>Feature:1>Background:2>Step:1>Step_Arg:0>__alt1:0>DataTable:0>#TableRow:0
    fn match_token_at_10(&mut self, token: Rc<RefCell<Token>>, context: &mut ParserContext) -> Result<u32> {
        if self.match_eof(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::DataTable)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Background)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(27);
        }
        if self.match_table_row(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(10);
        }
        if self.match_step_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::DataTable)?;
            self.end_rule(context, RuleType::Step)?;
            self.start_rule(context, RuleType::Step)?;
            self.build(context, token)?;
            return Ok(9);
        }
        if self.match_tag_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::DataTable)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_scenario_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::DataTable)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_scenario_outline_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::DataTable)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioOutline)?;
            self.build(context, token)?;
            return Ok(17);
        }
        if self.match_comment(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(10);
        }
        if self.match_empty(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(10);
        }

        let state_comment = String::from("State: 10 - GherkinDocument:0>Feature:1>Background:2>Step:1>Step_Arg:0>__alt1:0>DataTable:0>#TableRow:0");
        token.borrow().detach();
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#TableRow"),
            String::from("#StepLine"),
            String::from("#TagLine"),
            String::from("#ScenarioLine"),
            String::from("#ScenarioOutlineLine"),
            String::from("#Comment"),
            String::from("#Empty"),
        ];

        let token = token.borrow();
        let error = if token.is_eof() {
            let location = token.location;
            let expected = expected_tokens.join(", ");
            let message = format!("unexpected end of file, expected: {}", expected);

            ErrorKind::UnexpectedEof {
                location,
                message,
                state_comment,
//                expected_tokens,
            }
        } else {
            let token_location = token.location.expect("token location");
            let location = if token_location.get_column() > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.get_line();
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };
            let received = token.get_token_value().trim();
            let expected = expected_tokens.join(", ");
            let message = format!("({}:{}): expected: {}, got '{}'",
                    location.get_line(), location.get_column(), expected, received);

            ErrorKind::UnexpectedToken {
                location,
                message,
                state_comment,
//                received_token: *token,
//                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error.into());
        }

        self.add_error(context, new_error(error));
        Ok(10)
    }

    // GherkinDocument:0>Feature:2>Scenario_Definition:0>Tags:0>#TagLine:0
    fn match_token_at_11(&mut self, token: Rc<RefCell<Token>>, context: &mut ParserContext) -> Result<u32> {
        if self.match_tag_line(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_scenario_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Tags)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_scenario_outline_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Tags)?;
            self.start_rule(context, RuleType::ScenarioOutline)?;
            self.build(context, token)?;
            return Ok(17);
        }
        if self.match_comment(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_empty(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(11);
        }

        let state_comment = String::from("State: 11 - GherkinDocument:0>Feature:2>Scenario_Definition:0>Tags:0>#TagLine:0");
        token.borrow().detach();
        let expected_tokens: Vec<String> = vec![
            String::from("#TagLine"),
            String::from("#ScenarioLine"),
            String::from("#ScenarioOutlineLine"),
            String::from("#Comment"),
            String::from("#Empty"),
        ];

        let token = token.borrow();
        let error = if token.is_eof() {
            let location = token.location;
            let expected = expected_tokens.join(", ");
            let message = format!("unexpected end of file, expected: {}", expected);

            ErrorKind::UnexpectedEof {
                location,
                message,
                state_comment,
//                expected_tokens,
            }
        } else {
            let token_location = token.location.expect("token location");
            let location = if token_location.get_column() > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.get_line();
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };
            let received = token.get_token_value().trim();
            let expected = expected_tokens.join(", ");
            let message = format!("({}:{}): expected: {}, got '{}'",
                    location.get_line(), location.get_column(), expected, received);

            ErrorKind::UnexpectedToken {
                location,
                message,
                state_comment,
//                received_token: *token,
//                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error.into());
        }

        self.add_error(context, new_error(error));
        Ok(11)
    }

    // GherkinDocument:0>Feature:2>Scenario_Definition:1>__alt0:0>Scenario:0>#ScenarioLine:0
    fn match_token_at_12(&mut self, token: Rc<RefCell<Token>>, context: &mut ParserContext) -> Result<u32> {
        if self.match_eof(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(27);
        }
        if self.match_empty(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_comment(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(14);
        }
        if self.match_step_line(context, &mut *token.borrow_mut())? {
            self.start_rule(context, RuleType::Step)?;
            self.build(context, token)?;
            return Ok(15);
        }
        if self.match_tag_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_scenario_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_scenario_outline_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioOutline)?;
            self.build(context, token)?;
            return Ok(17);
        }
        if self.match_other(context, &mut *token.borrow_mut())? {
            self.start_rule(context, RuleType::Description)?;
            self.build(context, token)?;
            return Ok(13);
        }

        let state_comment = String::from("State: 12 - GherkinDocument:0>Feature:2>Scenario_Definition:1>__alt0:0>Scenario:0>#ScenarioLine:0");
        token.borrow().detach();
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#Empty"),
            String::from("#Comment"),
            String::from("#StepLine"),
            String::from("#TagLine"),
            String::from("#ScenarioLine"),
            String::from("#ScenarioOutlineLine"),
            String::from("#Other"),
        ];

        let token = token.borrow();
        let error = if token.is_eof() {
            let location = token.location;
            let expected = expected_tokens.join(", ");
            let message = format!("unexpected end of file, expected: {}", expected);

            ErrorKind::UnexpectedEof {
                location,
                message,
                state_comment,
//                expected_tokens,
            }
        } else {
            let token_location = token.location.expect("token location");
            let location = if token_location.get_column() > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.get_line();
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };
            let received = token.get_token_value().trim();
            let expected = expected_tokens.join(", ");
            let message = format!("({}:{}): expected: {}, got '{}'",
                    location.get_line(), location.get_column(), expected, received);

            ErrorKind::UnexpectedToken {
                location,
                message,
                state_comment,
//                received_token: *token,
//                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error.into());
        }

        self.add_error(context, new_error(error));
        Ok(12)
    }

    // GherkinDocument:0>Feature:2>Scenario_Definition:1>__alt0:0>Scenario:1>Description_Helper:1>Description:0>#Other:0
    fn match_token_at_13(&mut self, token: Rc<RefCell<Token>>, context: &mut ParserContext) -> Result<u32> {
        if self.match_eof(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(27);
        }
        if self.match_comment(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Description)?;
            self.build(context, token)?;
            return Ok(14);
        }
        if self.match_step_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Description)?;
            self.start_rule(context, RuleType::Step)?;
            self.build(context, token)?;
            return Ok(15);
        }
        if self.match_tag_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_scenario_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_scenario_outline_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioOutline)?;
            self.build(context, token)?;
            return Ok(17);
        }
        if self.match_other(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(13);
        }

        let state_comment = String::from("State: 13 - GherkinDocument:0>Feature:2>Scenario_Definition:1>__alt0:0>Scenario:1>Description_Helper:1>Description:0>#Other:0");
        token.borrow().detach();
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#Comment"),
            String::from("#StepLine"),
            String::from("#TagLine"),
            String::from("#ScenarioLine"),
            String::from("#ScenarioOutlineLine"),
            String::from("#Other"),
        ];

        let token = token.borrow();
        let error = if token.is_eof() {
            let location = token.location;
            let expected = expected_tokens.join(", ");
            let message = format!("unexpected end of file, expected: {}", expected);

            ErrorKind::UnexpectedEof {
                location,
                message,
                state_comment,
//                expected_tokens,
            }
        } else {
            let token_location = token.location.expect("token location");
            let location = if token_location.get_column() > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.get_line();
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };
            let received = token.get_token_value().trim();
            let expected = expected_tokens.join(", ");
            let message = format!("({}:{}): expected: {}, got '{}'",
                    location.get_line(), location.get_column(), expected, received);

            ErrorKind::UnexpectedToken {
                location,
                message,
                state_comment,
//                received_token: *token,
//                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error.into());
        }

        self.add_error(context, new_error(error));
        Ok(13)
    }

    // GherkinDocument:0>Feature:2>Scenario_Definition:1>__alt0:0>Scenario:1>Description_Helper:2>#Comment:0
    fn match_token_at_14(&mut self, token: Rc<RefCell<Token>>, context: &mut ParserContext) -> Result<u32> {
        if self.match_eof(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(27);
        }
        if self.match_comment(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(14);
        }
        if self.match_step_line(context, &mut *token.borrow_mut())? {
            self.start_rule(context, RuleType::Step)?;
            self.build(context, token)?;
            return Ok(15);
        }
        if self.match_tag_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_scenario_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_scenario_outline_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioOutline)?;
            self.build(context, token)?;
            return Ok(17);
        }
        if self.match_empty(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(14);
        }

        let state_comment = String::from("State: 14 - GherkinDocument:0>Feature:2>Scenario_Definition:1>__alt0:0>Scenario:1>Description_Helper:2>#Comment:0");
        token.borrow().detach();
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#Comment"),
            String::from("#StepLine"),
            String::from("#TagLine"),
            String::from("#ScenarioLine"),
            String::from("#ScenarioOutlineLine"),
            String::from("#Empty"),
        ];

        let token = token.borrow();
        let error = if token.is_eof() {
            let location = token.location;
            let expected = expected_tokens.join(", ");
            let message = format!("unexpected end of file, expected: {}", expected);

            ErrorKind::UnexpectedEof {
                location,
                message,
                state_comment,
//                expected_tokens,
            }
        } else {
            let token_location = token.location.expect("token location");
            let location = if token_location.get_column() > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.get_line();
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };
            let received = token.get_token_value().trim();
            let expected = expected_tokens.join(", ");
            let message = format!("({}:{}): expected: {}, got '{}'",
                    location.get_line(), location.get_column(), expected, received);

            ErrorKind::UnexpectedToken {
                location,
                message,
                state_comment,
//                received_token: *token,
//                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error.into());
        }

        self.add_error(context, new_error(error));
        Ok(14)
    }

    // GherkinDocument:0>Feature:2>Scenario_Definition:1>__alt0:0>Scenario:2>Step:0>#StepLine:0
    fn match_token_at_15(&mut self, token: Rc<RefCell<Token>>, context: &mut ParserContext) -> Result<u32> {
        if self.match_eof(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(27);
        }
        if self.match_table_row(context, &mut *token.borrow_mut())? {
            self.start_rule(context, RuleType::DataTable)?;
            self.build(context, token)?;
            return Ok(16);
        }
        if self.match_doc_string_separator(context, &mut *token.borrow_mut())? {
            self.start_rule(context, RuleType::DocString)?;
            self.build(context, token)?;
            return Ok(30);
        }
        if self.match_step_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Step)?;
            self.start_rule(context, RuleType::Step)?;
            self.build(context, token)?;
            return Ok(15);
        }
        if self.match_tag_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_scenario_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_scenario_outline_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioOutline)?;
            self.build(context, token)?;
            return Ok(17);
        }
        if self.match_comment(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(15);
        }
        if self.match_empty(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(15);
        }

        let state_comment = String::from("State: 15 - GherkinDocument:0>Feature:2>Scenario_Definition:1>__alt0:0>Scenario:2>Step:0>#StepLine:0");
        token.borrow().detach();
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#TableRow"),
            String::from("#DocStringSeparator"),
            String::from("#StepLine"),
            String::from("#TagLine"),
            String::from("#ScenarioLine"),
            String::from("#ScenarioOutlineLine"),
            String::from("#Comment"),
            String::from("#Empty"),
        ];

        let token = token.borrow();
        let error = if token.is_eof() {
            let location = token.location;
            let expected = expected_tokens.join(", ");
            let message = format!("unexpected end of file, expected: {}", expected);

            ErrorKind::UnexpectedEof {
                location,
                message,
                state_comment,
//                expected_tokens,
            }
        } else {
            let token_location = token.location.expect("token location");
            let location = if token_location.get_column() > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.get_line();
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };
            let received = token.get_token_value().trim();
            let expected = expected_tokens.join(", ");
            let message = format!("({}:{}): expected: {}, got '{}'",
                    location.get_line(), location.get_column(), expected, received);

            ErrorKind::UnexpectedToken {
                location,
                message,
                state_comment,
//                received_token: *token,
//                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error.into());
        }

        self.add_error(context, new_error(error));
        Ok(15)
    }

    // GherkinDocument:0>Feature:2>Scenario_Definition:1>__alt0:0>Scenario:2>Step:1>Step_Arg:0>__alt1:0>DataTable:0>#TableRow:0
    fn match_token_at_16(&mut self, token: Rc<RefCell<Token>>, context: &mut ParserContext) -> Result<u32> {
        if self.match_eof(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::DataTable)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(27);
        }
        if self.match_table_row(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(16);
        }
        if self.match_step_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::DataTable)?;
            self.end_rule(context, RuleType::Step)?;
            self.start_rule(context, RuleType::Step)?;
            self.build(context, token)?;
            return Ok(15);
        }
        if self.match_tag_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::DataTable)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_scenario_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::DataTable)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_scenario_outline_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::DataTable)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioOutline)?;
            self.build(context, token)?;
            return Ok(17);
        }
        if self.match_comment(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(16);
        }
        if self.match_empty(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(16);
        }

        let state_comment = String::from("State: 16 - GherkinDocument:0>Feature:2>Scenario_Definition:1>__alt0:0>Scenario:2>Step:1>Step_Arg:0>__alt1:0>DataTable:0>#TableRow:0");
        token.borrow().detach();
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#TableRow"),
            String::from("#StepLine"),
            String::from("#TagLine"),
            String::from("#ScenarioLine"),
            String::from("#ScenarioOutlineLine"),
            String::from("#Comment"),
            String::from("#Empty"),
        ];

        let token = token.borrow();
        let error = if token.is_eof() {
            let location = token.location;
            let expected = expected_tokens.join(", ");
            let message = format!("unexpected end of file, expected: {}", expected);

            ErrorKind::UnexpectedEof {
                location,
                message,
                state_comment,
//                expected_tokens,
            }
        } else {
            let token_location = token.location.expect("token location");
            let location = if token_location.get_column() > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.get_line();
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };
            let received = token.get_token_value().trim();
            let expected = expected_tokens.join(", ");
            let message = format!("({}:{}): expected: {}, got '{}'",
                    location.get_line(), location.get_column(), expected, received);

            ErrorKind::UnexpectedToken {
                location,
                message,
                state_comment,
//                received_token: *token,
//                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error.into());
        }

        self.add_error(context, new_error(error));
        Ok(16)
    }

    // GherkinDocument:0>Feature:2>Scenario_Definition:1>__alt0:1>ScenarioOutline:0>#ScenarioOutlineLine:0
    fn match_token_at_17(&mut self, token: Rc<RefCell<Token>>, context: &mut ParserContext) -> Result<u32> {
        if self.match_eof(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::ScenarioOutline)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(27);
        }
        if self.match_empty(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(17);
        }
        if self.match_comment(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(19);
        }
        if self.match_step_line(context, &mut *token.borrow_mut())? {
            self.start_rule(context, RuleType::Step)?;
            self.build(context, token)?;
            return Ok(20);
        }
        let match_tag_line_with_lookahead = {
            // Workaround for borrow checking
            let mut token_borrow = token.borrow_mut();
            self.match_tag_line(context, &mut token_borrow)?
                && self.lookahead_0(context, &token_borrow)
        };
        if match_tag_line_with_lookahead {
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_tag_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::ScenarioOutline)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_examples_line(context, &mut *token.borrow_mut())? {
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Examples)?;
            self.build(context, token)?;
            return Ok(23);
        }
        if self.match_scenario_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::ScenarioOutline)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_scenario_outline_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::ScenarioOutline)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioOutline)?;
            self.build(context, token)?;
            return Ok(17);
        }
        if self.match_other(context, &mut *token.borrow_mut())? {
            self.start_rule(context, RuleType::Description)?;
            self.build(context, token)?;
            return Ok(18);
        }

        let state_comment = String::from("State: 17 - GherkinDocument:0>Feature:2>Scenario_Definition:1>__alt0:1>ScenarioOutline:0>#ScenarioOutlineLine:0");
        token.borrow().detach();
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#Empty"),
            String::from("#Comment"),
            String::from("#StepLine"),
            String::from("#TagLine"),
            String::from("#ExamplesLine"),
            String::from("#ScenarioLine"),
            String::from("#ScenarioOutlineLine"),
            String::from("#Other"),
        ];

        let token = token.borrow();
        let error = if token.is_eof() {
            let location = token.location;
            let expected = expected_tokens.join(", ");
            let message = format!("unexpected end of file, expected: {}", expected);

            ErrorKind::UnexpectedEof {
                location,
                message,
                state_comment,
//                expected_tokens,
            }
        } else {
            let token_location = token.location.expect("token location");
            let location = if token_location.get_column() > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.get_line();
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };
            let received = token.get_token_value().trim();
            let expected = expected_tokens.join(", ");
            let message = format!("({}:{}): expected: {}, got '{}'",
                    location.get_line(), location.get_column(), expected, received);

            ErrorKind::UnexpectedToken {
                location,
                message,
                state_comment,
//                received_token: *token,
//                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error.into());
        }

        self.add_error(context, new_error(error));
        Ok(17)
    }

    // GherkinDocument:0>Feature:2>Scenario_Definition:1>__alt0:1>ScenarioOutline:1>Description_Helper:1>Description:0>#Other:0
    fn match_token_at_18(&mut self, token: Rc<RefCell<Token>>, context: &mut ParserContext) -> Result<u32> {
        if self.match_eof(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::ScenarioOutline)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(27);
        }
        if self.match_comment(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Description)?;
            self.build(context, token)?;
            return Ok(19);
        }
        if self.match_step_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Description)?;
            self.start_rule(context, RuleType::Step)?;
            self.build(context, token)?;
            return Ok(20);
        }
        let match_tag_line_with_lookahead = {
            // Workaround for borrow checking
            let mut token_borrow = token.borrow_mut();
            self.match_tag_line(context, &mut token_borrow)?
                && self.lookahead_0(context, &token_borrow)
        };
        if match_tag_line_with_lookahead {
            self.end_rule(context, RuleType::Description)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_tag_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::ScenarioOutline)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_examples_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Description)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Examples)?;
            self.build(context, token)?;
            return Ok(23);
        }
        if self.match_scenario_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::ScenarioOutline)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_scenario_outline_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::ScenarioOutline)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioOutline)?;
            self.build(context, token)?;
            return Ok(17);
        }
        if self.match_other(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(18);
        }

        let state_comment = String::from("State: 18 - GherkinDocument:0>Feature:2>Scenario_Definition:1>__alt0:1>ScenarioOutline:1>Description_Helper:1>Description:0>#Other:0");
        token.borrow().detach();
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#Comment"),
            String::from("#StepLine"),
            String::from("#TagLine"),
            String::from("#ExamplesLine"),
            String::from("#ScenarioLine"),
            String::from("#ScenarioOutlineLine"),
            String::from("#Other"),
        ];

        let token = token.borrow();
        let error = if token.is_eof() {
            let location = token.location;
            let expected = expected_tokens.join(", ");
            let message = format!("unexpected end of file, expected: {}", expected);

            ErrorKind::UnexpectedEof {
                location,
                message,
                state_comment,
//                expected_tokens,
            }
        } else {
            let token_location = token.location.expect("token location");
            let location = if token_location.get_column() > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.get_line();
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };
            let received = token.get_token_value().trim();
            let expected = expected_tokens.join(", ");
            let message = format!("({}:{}): expected: {}, got '{}'",
                    location.get_line(), location.get_column(), expected, received);

            ErrorKind::UnexpectedToken {
                location,
                message,
                state_comment,
//                received_token: *token,
//                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error.into());
        }

        self.add_error(context, new_error(error));
        Ok(18)
    }

    // GherkinDocument:0>Feature:2>Scenario_Definition:1>__alt0:1>ScenarioOutline:1>Description_Helper:2>#Comment:0
    fn match_token_at_19(&mut self, token: Rc<RefCell<Token>>, context: &mut ParserContext) -> Result<u32> {
        if self.match_eof(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::ScenarioOutline)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(27);
        }
        if self.match_comment(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(19);
        }
        if self.match_step_line(context, &mut *token.borrow_mut())? {
            self.start_rule(context, RuleType::Step)?;
            self.build(context, token)?;
            return Ok(20);
        }
        let match_tag_line_with_lookahead = {
            // Workaround for borrow checking
            let mut token_borrow = token.borrow_mut();
            self.match_tag_line(context, &mut token_borrow)?
                && self.lookahead_0(context, &token_borrow)
        };
        if match_tag_line_with_lookahead {
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_tag_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::ScenarioOutline)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_examples_line(context, &mut *token.borrow_mut())? {
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Examples)?;
            self.build(context, token)?;
            return Ok(23);
        }
        if self.match_scenario_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::ScenarioOutline)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_scenario_outline_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::ScenarioOutline)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioOutline)?;
            self.build(context, token)?;
            return Ok(17);
        }
        if self.match_empty(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(19);
        }

        let state_comment = String::from("State: 19 - GherkinDocument:0>Feature:2>Scenario_Definition:1>__alt0:1>ScenarioOutline:1>Description_Helper:2>#Comment:0");
        token.borrow().detach();
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#Comment"),
            String::from("#StepLine"),
            String::from("#TagLine"),
            String::from("#ExamplesLine"),
            String::from("#ScenarioLine"),
            String::from("#ScenarioOutlineLine"),
            String::from("#Empty"),
        ];

        let token = token.borrow();
        let error = if token.is_eof() {
            let location = token.location;
            let expected = expected_tokens.join(", ");
            let message = format!("unexpected end of file, expected: {}", expected);

            ErrorKind::UnexpectedEof {
                location,
                message,
                state_comment,
//                expected_tokens,
            }
        } else {
            let token_location = token.location.expect("token location");
            let location = if token_location.get_column() > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.get_line();
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };
            let received = token.get_token_value().trim();
            let expected = expected_tokens.join(", ");
            let message = format!("({}:{}): expected: {}, got '{}'",
                    location.get_line(), location.get_column(), expected, received);

            ErrorKind::UnexpectedToken {
                location,
                message,
                state_comment,
//                received_token: *token,
//                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error.into());
        }

        self.add_error(context, new_error(error));
        Ok(19)
    }

    // GherkinDocument:0>Feature:2>Scenario_Definition:1>__alt0:1>ScenarioOutline:2>Step:0>#StepLine:0
    fn match_token_at_20(&mut self, token: Rc<RefCell<Token>>, context: &mut ParserContext) -> Result<u32> {
        if self.match_eof(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::ScenarioOutline)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(27);
        }
        if self.match_table_row(context, &mut *token.borrow_mut())? {
            self.start_rule(context, RuleType::DataTable)?;
            self.build(context, token)?;
            return Ok(21);
        }
        if self.match_doc_string_separator(context, &mut *token.borrow_mut())? {
            self.start_rule(context, RuleType::DocString)?;
            self.build(context, token)?;
            return Ok(28);
        }
        if self.match_step_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Step)?;
            self.start_rule(context, RuleType::Step)?;
            self.build(context, token)?;
            return Ok(20);
        }
        let match_tag_line_with_lookahead = {
            // Workaround for borrow checking
            let mut token_borrow = token.borrow_mut();
            self.match_tag_line(context, &mut token_borrow)?
                && self.lookahead_0(context, &token_borrow)
        };
        if match_tag_line_with_lookahead {
            self.end_rule(context, RuleType::Step)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_tag_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::ScenarioOutline)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_examples_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Step)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Examples)?;
            self.build(context, token)?;
            return Ok(23);
        }
        if self.match_scenario_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::ScenarioOutline)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_scenario_outline_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::ScenarioOutline)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioOutline)?;
            self.build(context, token)?;
            return Ok(17);
        }
        if self.match_comment(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(20);
        }
        if self.match_empty(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(20);
        }

        let state_comment = String::from("State: 20 - GherkinDocument:0>Feature:2>Scenario_Definition:1>__alt0:1>ScenarioOutline:2>Step:0>#StepLine:0");
        token.borrow().detach();
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#TableRow"),
            String::from("#DocStringSeparator"),
            String::from("#StepLine"),
            String::from("#TagLine"),
            String::from("#ExamplesLine"),
            String::from("#ScenarioLine"),
            String::from("#ScenarioOutlineLine"),
            String::from("#Comment"),
            String::from("#Empty"),
        ];

        let token = token.borrow();
        let error = if token.is_eof() {
            let location = token.location;
            let expected = expected_tokens.join(", ");
            let message = format!("unexpected end of file, expected: {}", expected);

            ErrorKind::UnexpectedEof {
                location,
                message,
                state_comment,
//                expected_tokens,
            }
        } else {
            let token_location = token.location.expect("token location");
            let location = if token_location.get_column() > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.get_line();
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };
            let received = token.get_token_value().trim();
            let expected = expected_tokens.join(", ");
            let message = format!("({}:{}): expected: {}, got '{}'",
                    location.get_line(), location.get_column(), expected, received);

            ErrorKind::UnexpectedToken {
                location,
                message,
                state_comment,
//                received_token: *token,
//                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error.into());
        }

        self.add_error(context, new_error(error));
        Ok(20)
    }

    // GherkinDocument:0>Feature:2>Scenario_Definition:1>__alt0:1>ScenarioOutline:2>Step:1>Step_Arg:0>__alt1:0>DataTable:0>#TableRow:0
    fn match_token_at_21(&mut self, token: Rc<RefCell<Token>>, context: &mut ParserContext) -> Result<u32> {
        if self.match_eof(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::DataTable)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::ScenarioOutline)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(27);
        }
        if self.match_table_row(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(21);
        }
        if self.match_step_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::DataTable)?;
            self.end_rule(context, RuleType::Step)?;
            self.start_rule(context, RuleType::Step)?;
            self.build(context, token)?;
            return Ok(20);
        }
        let match_tag_line_with_lookahead = {
            // Workaround for borrow checking
            let mut token_borrow = token.borrow_mut();
            self.match_tag_line(context, &mut token_borrow)?
                && self.lookahead_0(context, &token_borrow)
        };
        if match_tag_line_with_lookahead {
            self.end_rule(context, RuleType::DataTable)?;
            self.end_rule(context, RuleType::Step)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_tag_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::DataTable)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::ScenarioOutline)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_examples_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::DataTable)?;
            self.end_rule(context, RuleType::Step)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Examples)?;
            self.build(context, token)?;
            return Ok(23);
        }
        if self.match_scenario_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::DataTable)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::ScenarioOutline)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_scenario_outline_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::DataTable)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::ScenarioOutline)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioOutline)?;
            self.build(context, token)?;
            return Ok(17);
        }
        if self.match_comment(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(21);
        }
        if self.match_empty(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(21);
        }

        let state_comment = String::from("State: 21 - GherkinDocument:0>Feature:2>Scenario_Definition:1>__alt0:1>ScenarioOutline:2>Step:1>Step_Arg:0>__alt1:0>DataTable:0>#TableRow:0");
        token.borrow().detach();
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#TableRow"),
            String::from("#StepLine"),
            String::from("#TagLine"),
            String::from("#ExamplesLine"),
            String::from("#ScenarioLine"),
            String::from("#ScenarioOutlineLine"),
            String::from("#Comment"),
            String::from("#Empty"),
        ];

        let token = token.borrow();
        let error = if token.is_eof() {
            let location = token.location;
            let expected = expected_tokens.join(", ");
            let message = format!("unexpected end of file, expected: {}", expected);

            ErrorKind::UnexpectedEof {
                location,
                message,
                state_comment,
//                expected_tokens,
            }
        } else {
            let token_location = token.location.expect("token location");
            let location = if token_location.get_column() > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.get_line();
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };
            let received = token.get_token_value().trim();
            let expected = expected_tokens.join(", ");
            let message = format!("({}:{}): expected: {}, got '{}'",
                    location.get_line(), location.get_column(), expected, received);

            ErrorKind::UnexpectedToken {
                location,
                message,
                state_comment,
//                received_token: *token,
//                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error.into());
        }

        self.add_error(context, new_error(error));
        Ok(21)
    }

    // GherkinDocument:0>Feature:2>Scenario_Definition:1>__alt0:1>ScenarioOutline:3>Examples_Definition:0>Tags:0>#TagLine:0
    fn match_token_at_22(&mut self, token: Rc<RefCell<Token>>, context: &mut ParserContext) -> Result<u32> {
        if self.match_tag_line(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_examples_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Tags)?;
            self.start_rule(context, RuleType::Examples)?;
            self.build(context, token)?;
            return Ok(23);
        }
        if self.match_comment(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_empty(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(22);
        }

        let state_comment = String::from("State: 22 - GherkinDocument:0>Feature:2>Scenario_Definition:1>__alt0:1>ScenarioOutline:3>Examples_Definition:0>Tags:0>#TagLine:0");
        token.borrow().detach();
        let expected_tokens: Vec<String> = vec![
            String::from("#TagLine"),
            String::from("#ExamplesLine"),
            String::from("#Comment"),
            String::from("#Empty"),
        ];

        let token = token.borrow();
        let error = if token.is_eof() {
            let location = token.location;
            let expected = expected_tokens.join(", ");
            let message = format!("unexpected end of file, expected: {}", expected);

            ErrorKind::UnexpectedEof {
                location,
                message,
                state_comment,
//                expected_tokens,
            }
        } else {
            let token_location = token.location.expect("token location");
            let location = if token_location.get_column() > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.get_line();
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };
            let received = token.get_token_value().trim();
            let expected = expected_tokens.join(", ");
            let message = format!("({}:{}): expected: {}, got '{}'",
                    location.get_line(), location.get_column(), expected, received);

            ErrorKind::UnexpectedToken {
                location,
                message,
                state_comment,
//                received_token: *token,
//                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error.into());
        }

        self.add_error(context, new_error(error));
        Ok(22)
    }

    // GherkinDocument:0>Feature:2>Scenario_Definition:1>__alt0:1>ScenarioOutline:3>Examples_Definition:1>Examples:0>#ExamplesLine:0
    fn match_token_at_23(&mut self, token: Rc<RefCell<Token>>, context: &mut ParserContext) -> Result<u32> {
        if self.match_eof(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::ScenarioOutline)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(27);
        }
        if self.match_empty(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(23);
        }
        if self.match_comment(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(25);
        }
        if self.match_table_row(context, &mut *token.borrow_mut())? {
            self.start_rule(context, RuleType::ExamplesTable)?;
            self.build(context, token)?;
            return Ok(26);
        }
        let match_tag_line_with_lookahead = {
            // Workaround for borrow checking
            let mut token_borrow = token.borrow_mut();
            self.match_tag_line(context, &mut token_borrow)?
                && self.lookahead_0(context, &token_borrow)
        };
        if match_tag_line_with_lookahead {
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_tag_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::ScenarioOutline)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_examples_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Examples)?;
            self.build(context, token)?;
            return Ok(23);
        }
        if self.match_scenario_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::ScenarioOutline)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_scenario_outline_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::ScenarioOutline)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioOutline)?;
            self.build(context, token)?;
            return Ok(17);
        }
        if self.match_other(context, &mut *token.borrow_mut())? {
            self.start_rule(context, RuleType::Description)?;
            self.build(context, token)?;
            return Ok(24);
        }

        let state_comment = String::from("State: 23 - GherkinDocument:0>Feature:2>Scenario_Definition:1>__alt0:1>ScenarioOutline:3>Examples_Definition:1>Examples:0>#ExamplesLine:0");
        token.borrow().detach();
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#Empty"),
            String::from("#Comment"),
            String::from("#TableRow"),
            String::from("#TagLine"),
            String::from("#ExamplesLine"),
            String::from("#ScenarioLine"),
            String::from("#ScenarioOutlineLine"),
            String::from("#Other"),
        ];

        let token = token.borrow();
        let error = if token.is_eof() {
            let location = token.location;
            let expected = expected_tokens.join(", ");
            let message = format!("unexpected end of file, expected: {}", expected);

            ErrorKind::UnexpectedEof {
                location,
                message,
                state_comment,
//                expected_tokens,
            }
        } else {
            let token_location = token.location.expect("token location");
            let location = if token_location.get_column() > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.get_line();
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };
            let received = token.get_token_value().trim();
            let expected = expected_tokens.join(", ");
            let message = format!("({}:{}): expected: {}, got '{}'",
                    location.get_line(), location.get_column(), expected, received);

            ErrorKind::UnexpectedToken {
                location,
                message,
                state_comment,
//                received_token: *token,
//                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error.into());
        }

        self.add_error(context, new_error(error));
        Ok(23)
    }

    // GherkinDocument:0>Feature:2>Scenario_Definition:1>__alt0:1>ScenarioOutline:3>Examples_Definition:1>Examples:1>Description_Helper:1>Description:0>#Other:0
    fn match_token_at_24(&mut self, token: Rc<RefCell<Token>>, context: &mut ParserContext) -> Result<u32> {
        if self.match_eof(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::ScenarioOutline)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(27);
        }
        if self.match_comment(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Description)?;
            self.build(context, token)?;
            return Ok(25);
        }
        if self.match_table_row(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Description)?;
            self.start_rule(context, RuleType::ExamplesTable)?;
            self.build(context, token)?;
            return Ok(26);
        }
        let match_tag_line_with_lookahead = {
            // Workaround for borrow checking
            let mut token_borrow = token.borrow_mut();
            self.match_tag_line(context, &mut token_borrow)?
                && self.lookahead_0(context, &token_borrow)
        };
        if match_tag_line_with_lookahead {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_tag_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::ScenarioOutline)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_examples_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Examples)?;
            self.build(context, token)?;
            return Ok(23);
        }
        if self.match_scenario_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::ScenarioOutline)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_scenario_outline_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::ScenarioOutline)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioOutline)?;
            self.build(context, token)?;
            return Ok(17);
        }
        if self.match_other(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(24);
        }

        let state_comment = String::from("State: 24 - GherkinDocument:0>Feature:2>Scenario_Definition:1>__alt0:1>ScenarioOutline:3>Examples_Definition:1>Examples:1>Description_Helper:1>Description:0>#Other:0");
        token.borrow().detach();
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#Comment"),
            String::from("#TableRow"),
            String::from("#TagLine"),
            String::from("#ExamplesLine"),
            String::from("#ScenarioLine"),
            String::from("#ScenarioOutlineLine"),
            String::from("#Other"),
        ];

        let token = token.borrow();
        let error = if token.is_eof() {
            let location = token.location;
            let expected = expected_tokens.join(", ");
            let message = format!("unexpected end of file, expected: {}", expected);

            ErrorKind::UnexpectedEof {
                location,
                message,
                state_comment,
//                expected_tokens,
            }
        } else {
            let token_location = token.location.expect("token location");
            let location = if token_location.get_column() > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.get_line();
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };
            let received = token.get_token_value().trim();
            let expected = expected_tokens.join(", ");
            let message = format!("({}:{}): expected: {}, got '{}'",
                    location.get_line(), location.get_column(), expected, received);

            ErrorKind::UnexpectedToken {
                location,
                message,
                state_comment,
//                received_token: *token,
//                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error.into());
        }

        self.add_error(context, new_error(error));
        Ok(24)
    }

    // GherkinDocument:0>Feature:2>Scenario_Definition:1>__alt0:1>ScenarioOutline:3>Examples_Definition:1>Examples:1>Description_Helper:2>#Comment:0
    fn match_token_at_25(&mut self, token: Rc<RefCell<Token>>, context: &mut ParserContext) -> Result<u32> {
        if self.match_eof(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::ScenarioOutline)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(27);
        }
        if self.match_comment(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(25);
        }
        if self.match_table_row(context, &mut *token.borrow_mut())? {
            self.start_rule(context, RuleType::ExamplesTable)?;
            self.build(context, token)?;
            return Ok(26);
        }
        let match_tag_line_with_lookahead = {
            // Workaround for borrow checking
            let mut token_borrow = token.borrow_mut();
            self.match_tag_line(context, &mut token_borrow)?
                && self.lookahead_0(context, &token_borrow)
        };
        if match_tag_line_with_lookahead {
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_tag_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::ScenarioOutline)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_examples_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Examples)?;
            self.build(context, token)?;
            return Ok(23);
        }
        if self.match_scenario_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::ScenarioOutline)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_scenario_outline_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::ScenarioOutline)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioOutline)?;
            self.build(context, token)?;
            return Ok(17);
        }
        if self.match_empty(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(25);
        }

        let state_comment = String::from("State: 25 - GherkinDocument:0>Feature:2>Scenario_Definition:1>__alt0:1>ScenarioOutline:3>Examples_Definition:1>Examples:1>Description_Helper:2>#Comment:0");
        token.borrow().detach();
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#Comment"),
            String::from("#TableRow"),
            String::from("#TagLine"),
            String::from("#ExamplesLine"),
            String::from("#ScenarioLine"),
            String::from("#ScenarioOutlineLine"),
            String::from("#Empty"),
        ];

        let token = token.borrow();
        let error = if token.is_eof() {
            let location = token.location;
            let expected = expected_tokens.join(", ");
            let message = format!("unexpected end of file, expected: {}", expected);

            ErrorKind::UnexpectedEof {
                location,
                message,
                state_comment,
//                expected_tokens,
            }
        } else {
            let token_location = token.location.expect("token location");
            let location = if token_location.get_column() > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.get_line();
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };
            let received = token.get_token_value().trim();
            let expected = expected_tokens.join(", ");
            let message = format!("({}:{}): expected: {}, got '{}'",
                    location.get_line(), location.get_column(), expected, received);

            ErrorKind::UnexpectedToken {
                location,
                message,
                state_comment,
//                received_token: *token,
//                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error.into());
        }

        self.add_error(context, new_error(error));
        Ok(25)
    }

    // GherkinDocument:0>Feature:2>Scenario_Definition:1>__alt0:1>ScenarioOutline:3>Examples_Definition:1>Examples:2>Examples_Table:0>#TableRow:0
    fn match_token_at_26(&mut self, token: Rc<RefCell<Token>>, context: &mut ParserContext) -> Result<u32> {
        if self.match_eof(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::ExamplesTable)?;
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::ScenarioOutline)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(27);
        }
        if self.match_table_row(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(26);
        }
        let match_tag_line_with_lookahead = {
            // Workaround for borrow checking
            let mut token_borrow = token.borrow_mut();
            self.match_tag_line(context, &mut token_borrow)?
                && self.lookahead_0(context, &token_borrow)
        };
        if match_tag_line_with_lookahead {
            self.end_rule(context, RuleType::ExamplesTable)?;
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_tag_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::ExamplesTable)?;
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::ScenarioOutline)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_examples_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::ExamplesTable)?;
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Examples)?;
            self.build(context, token)?;
            return Ok(23);
        }
        if self.match_scenario_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::ExamplesTable)?;
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::ScenarioOutline)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_scenario_outline_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::ExamplesTable)?;
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::ScenarioOutline)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioOutline)?;
            self.build(context, token)?;
            return Ok(17);
        }
        if self.match_comment(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(26);
        }
        if self.match_empty(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(26);
        }

        let state_comment = String::from("State: 26 - GherkinDocument:0>Feature:2>Scenario_Definition:1>__alt0:1>ScenarioOutline:3>Examples_Definition:1>Examples:2>Examples_Table:0>#TableRow:0");
        token.borrow().detach();
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#TableRow"),
            String::from("#TagLine"),
            String::from("#ExamplesLine"),
            String::from("#ScenarioLine"),
            String::from("#ScenarioOutlineLine"),
            String::from("#Comment"),
            String::from("#Empty"),
        ];

        let token = token.borrow();
        let error = if token.is_eof() {
            let location = token.location;
            let expected = expected_tokens.join(", ");
            let message = format!("unexpected end of file, expected: {}", expected);

            ErrorKind::UnexpectedEof {
                location,
                message,
                state_comment,
//                expected_tokens,
            }
        } else {
            let token_location = token.location.expect("token location");
            let location = if token_location.get_column() > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.get_line();
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };
            let received = token.get_token_value().trim();
            let expected = expected_tokens.join(", ");
            let message = format!("({}:{}): expected: {}, got '{}'",
                    location.get_line(), location.get_column(), expected, received);

            ErrorKind::UnexpectedToken {
                location,
                message,
                state_comment,
//                received_token: *token,
//                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error.into());
        }

        self.add_error(context, new_error(error));
        Ok(26)
    }

    // GherkinDocument:0>Feature:2>Scenario_Definition:1>__alt0:1>ScenarioOutline:2>Step:1>Step_Arg:0>__alt1:1>DocString:0>#DocStringSeparator:0
    fn match_token_at_28(&mut self, token: Rc<RefCell<Token>>, context: &mut ParserContext) -> Result<u32> {
        if self.match_doc_string_separator(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(29);
        }
        if self.match_other(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(28);
        }

        let state_comment = String::from("State: 28 - GherkinDocument:0>Feature:2>Scenario_Definition:1>__alt0:1>ScenarioOutline:2>Step:1>Step_Arg:0>__alt1:1>DocString:0>#DocStringSeparator:0");
        token.borrow().detach();
        let expected_tokens: Vec<String> = vec![
            String::from("#DocStringSeparator"),
            String::from("#Other"),
        ];

        let token = token.borrow();
        let error = if token.is_eof() {
            let location = token.location;
            let expected = expected_tokens.join(", ");
            let message = format!("unexpected end of file, expected: {}", expected);

            ErrorKind::UnexpectedEof {
                location,
                message,
                state_comment,
//                expected_tokens,
            }
        } else {
            let token_location = token.location.expect("token location");
            let location = if token_location.get_column() > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.get_line();
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };
            let received = token.get_token_value().trim();
            let expected = expected_tokens.join(", ");
            let message = format!("({}:{}): expected: {}, got '{}'",
                    location.get_line(), location.get_column(), expected, received);

            ErrorKind::UnexpectedToken {
                location,
                message,
                state_comment,
//                received_token: *token,
//                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error.into());
        }

        self.add_error(context, new_error(error));
        Ok(28)
    }

    // GherkinDocument:0>Feature:2>Scenario_Definition:1>__alt0:1>ScenarioOutline:2>Step:1>Step_Arg:0>__alt1:1>DocString:2>#DocStringSeparator:0
    fn match_token_at_29(&mut self, token: Rc<RefCell<Token>>, context: &mut ParserContext) -> Result<u32> {
        if self.match_eof(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::DocString)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::ScenarioOutline)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(27);
        }
        if self.match_step_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::DocString)?;
            self.end_rule(context, RuleType::Step)?;
            self.start_rule(context, RuleType::Step)?;
            self.build(context, token)?;
            return Ok(20);
        }
        let match_tag_line_with_lookahead = {
            // Workaround for borrow checking
            let mut token_borrow = token.borrow_mut();
            self.match_tag_line(context, &mut token_borrow)?
                && self.lookahead_0(context, &token_borrow)
        };
        if match_tag_line_with_lookahead {
            self.end_rule(context, RuleType::DocString)?;
            self.end_rule(context, RuleType::Step)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_tag_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::DocString)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::ScenarioOutline)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_examples_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::DocString)?;
            self.end_rule(context, RuleType::Step)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Examples)?;
            self.build(context, token)?;
            return Ok(23);
        }
        if self.match_scenario_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::DocString)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::ScenarioOutline)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_scenario_outline_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::DocString)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::ScenarioOutline)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioOutline)?;
            self.build(context, token)?;
            return Ok(17);
        }
        if self.match_comment(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(29);
        }
        if self.match_empty(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(29);
        }

        let state_comment = String::from("State: 29 - GherkinDocument:0>Feature:2>Scenario_Definition:1>__alt0:1>ScenarioOutline:2>Step:1>Step_Arg:0>__alt1:1>DocString:2>#DocStringSeparator:0");
        token.borrow().detach();
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#StepLine"),
            String::from("#TagLine"),
            String::from("#ExamplesLine"),
            String::from("#ScenarioLine"),
            String::from("#ScenarioOutlineLine"),
            String::from("#Comment"),
            String::from("#Empty"),
        ];

        let token = token.borrow();
        let error = if token.is_eof() {
            let location = token.location;
            let expected = expected_tokens.join(", ");
            let message = format!("unexpected end of file, expected: {}", expected);

            ErrorKind::UnexpectedEof {
                location,
                message,
                state_comment,
//                expected_tokens,
            }
        } else {
            let token_location = token.location.expect("token location");
            let location = if token_location.get_column() > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.get_line();
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };
            let received = token.get_token_value().trim();
            let expected = expected_tokens.join(", ");
            let message = format!("({}:{}): expected: {}, got '{}'",
                    location.get_line(), location.get_column(), expected, received);

            ErrorKind::UnexpectedToken {
                location,
                message,
                state_comment,
//                received_token: *token,
//                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error.into());
        }

        self.add_error(context, new_error(error));
        Ok(29)
    }

    // GherkinDocument:0>Feature:2>Scenario_Definition:1>__alt0:0>Scenario:2>Step:1>Step_Arg:0>__alt1:1>DocString:0>#DocStringSeparator:0
    fn match_token_at_30(&mut self, token: Rc<RefCell<Token>>, context: &mut ParserContext) -> Result<u32> {
        if self.match_doc_string_separator(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(31);
        }
        if self.match_other(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(30);
        }

        let state_comment = String::from("State: 30 - GherkinDocument:0>Feature:2>Scenario_Definition:1>__alt0:0>Scenario:2>Step:1>Step_Arg:0>__alt1:1>DocString:0>#DocStringSeparator:0");
        token.borrow().detach();
        let expected_tokens: Vec<String> = vec![
            String::from("#DocStringSeparator"),
            String::from("#Other"),
        ];

        let token = token.borrow();
        let error = if token.is_eof() {
            let location = token.location;
            let expected = expected_tokens.join(", ");
            let message = format!("unexpected end of file, expected: {}", expected);

            ErrorKind::UnexpectedEof {
                location,
                message,
                state_comment,
//                expected_tokens,
            }
        } else {
            let token_location = token.location.expect("token location");
            let location = if token_location.get_column() > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.get_line();
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };
            let received = token.get_token_value().trim();
            let expected = expected_tokens.join(", ");
            let message = format!("({}:{}): expected: {}, got '{}'",
                    location.get_line(), location.get_column(), expected, received);

            ErrorKind::UnexpectedToken {
                location,
                message,
                state_comment,
//                received_token: *token,
//                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error.into());
        }

        self.add_error(context, new_error(error));
        Ok(30)
    }

    // GherkinDocument:0>Feature:2>Scenario_Definition:1>__alt0:0>Scenario:2>Step:1>Step_Arg:0>__alt1:1>DocString:2>#DocStringSeparator:0
    fn match_token_at_31(&mut self, token: Rc<RefCell<Token>>, context: &mut ParserContext) -> Result<u32> {
        if self.match_eof(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::DocString)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(27);
        }
        if self.match_step_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::DocString)?;
            self.end_rule(context, RuleType::Step)?;
            self.start_rule(context, RuleType::Step)?;
            self.build(context, token)?;
            return Ok(15);
        }
        if self.match_tag_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::DocString)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_scenario_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::DocString)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_scenario_outline_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::DocString)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioOutline)?;
            self.build(context, token)?;
            return Ok(17);
        }
        if self.match_comment(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(31);
        }
        if self.match_empty(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(31);
        }

        let state_comment = String::from("State: 31 - GherkinDocument:0>Feature:2>Scenario_Definition:1>__alt0:0>Scenario:2>Step:1>Step_Arg:0>__alt1:1>DocString:2>#DocStringSeparator:0");
        token.borrow().detach();
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#StepLine"),
            String::from("#TagLine"),
            String::from("#ScenarioLine"),
            String::from("#ScenarioOutlineLine"),
            String::from("#Comment"),
            String::from("#Empty"),
        ];

        let token = token.borrow();
        let error = if token.is_eof() {
            let location = token.location;
            let expected = expected_tokens.join(", ");
            let message = format!("unexpected end of file, expected: {}", expected);

            ErrorKind::UnexpectedEof {
                location,
                message,
                state_comment,
//                expected_tokens,
            }
        } else {
            let token_location = token.location.expect("token location");
            let location = if token_location.get_column() > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.get_line();
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };
            let received = token.get_token_value().trim();
            let expected = expected_tokens.join(", ");
            let message = format!("({}:{}): expected: {}, got '{}'",
                    location.get_line(), location.get_column(), expected, received);

            ErrorKind::UnexpectedToken {
                location,
                message,
                state_comment,
//                received_token: *token,
//                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error.into());
        }

        self.add_error(context, new_error(error));
        Ok(31)
    }

    // GherkinDocument:0>Feature:1>Background:2>Step:1>Step_Arg:0>__alt1:1>DocString:0>#DocStringSeparator:0
    fn match_token_at_32(&mut self, token: Rc<RefCell<Token>>, context: &mut ParserContext) -> Result<u32> {
        if self.match_doc_string_separator(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(33);
        }
        if self.match_other(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(32);
        }

        let state_comment = String::from("State: 32 - GherkinDocument:0>Feature:1>Background:2>Step:1>Step_Arg:0>__alt1:1>DocString:0>#DocStringSeparator:0");
        token.borrow().detach();
        let expected_tokens: Vec<String> = vec![
            String::from("#DocStringSeparator"),
            String::from("#Other"),
        ];

        let token = token.borrow();
        let error = if token.is_eof() {
            let location = token.location;
            let expected = expected_tokens.join(", ");
            let message = format!("unexpected end of file, expected: {}", expected);

            ErrorKind::UnexpectedEof {
                location,
                message,
                state_comment,
//                expected_tokens,
            }
        } else {
            let token_location = token.location.expect("token location");
            let location = if token_location.get_column() > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.get_line();
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };
            let received = token.get_token_value().trim();
            let expected = expected_tokens.join(", ");
            let message = format!("({}:{}): expected: {}, got '{}'",
                    location.get_line(), location.get_column(), expected, received);

            ErrorKind::UnexpectedToken {
                location,
                message,
                state_comment,
//                received_token: *token,
//                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error.into());
        }

        self.add_error(context, new_error(error));
        Ok(32)
    }

    // GherkinDocument:0>Feature:1>Background:2>Step:1>Step_Arg:0>__alt1:1>DocString:2>#DocStringSeparator:0
    fn match_token_at_33(&mut self, token: Rc<RefCell<Token>>, context: &mut ParserContext) -> Result<u32> {
        if self.match_eof(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::DocString)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Background)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(27);
        }
        if self.match_step_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::DocString)?;
            self.end_rule(context, RuleType::Step)?;
            self.start_rule(context, RuleType::Step)?;
            self.build(context, token)?;
            return Ok(9);
        }
        if self.match_tag_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::DocString)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_scenario_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::DocString)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_scenario_outline_line(context, &mut *token.borrow_mut())? {
            self.end_rule(context, RuleType::DocString)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioOutline)?;
            self.build(context, token)?;
            return Ok(17);
        }
        if self.match_comment(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(33);
        }
        if self.match_empty(context, &mut *token.borrow_mut())? {
            self.build(context, token)?;
            return Ok(33);
        }

        let state_comment = String::from("State: 33 - GherkinDocument:0>Feature:1>Background:2>Step:1>Step_Arg:0>__alt1:1>DocString:2>#DocStringSeparator:0");
        token.borrow().detach();
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#StepLine"),
            String::from("#TagLine"),
            String::from("#ScenarioLine"),
            String::from("#ScenarioOutlineLine"),
            String::from("#Comment"),
            String::from("#Empty"),
        ];

        let token = token.borrow();
        let error = if token.is_eof() {
            let location = token.location;
            let expected = expected_tokens.join(", ");
            let message = format!("unexpected end of file, expected: {}", expected);

            ErrorKind::UnexpectedEof {
                location,
                message,
                state_comment,
//                expected_tokens,
            }
        } else {
            let token_location = token.location.expect("token location");
            let location = if token_location.get_column() > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.get_line();
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };
            let received = token.get_token_value().trim();
            let expected = expected_tokens.join(", ");
            let message = format!("({}:{}): expected: {}, got '{}'",
                    location.get_line(), location.get_column(), expected, received);

            ErrorKind::UnexpectedToken {
                location,
                message,
                state_comment,
//                received_token: *token,
//                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error.into());
        }

        self.add_error(context, new_error(error));
        Ok(33)
    }

    fn lookahead_0(&mut self, context: &mut ParserContext, current_token: &Token) -> bool {
        current_token.detach();
        let mut token: Rc<RefCell<Token>>;
        let mut queue: VecDeque<Rc<RefCell<Token>>> = VecDeque::new();
        let mut found_match = false;
        loop {
            token = self.read_token(context).expect("read next token");
            token.borrow().detach();
            queue.push_back(token.clone());

            if false
                || self.match_examples_line(context, &mut *token.borrow_mut()) .unwrap_or(false)
            {
                found_match = true;
                break;
            }

             if true
                 && !self.match_empty(context, &mut *token.borrow_mut()) .unwrap_or(true)
                 && !self.match_comment(context, &mut *token.borrow_mut()) .unwrap_or(true)
                 && !self.match_tag_line(context, &mut *token.borrow_mut()) .unwrap_or(true)
             {
                 break;
             }
        }

        context.token_queue.extend(queue);

        found_match
    }
}

pub trait Builder {
    type BuilderResult;

    fn build(&mut self, token: Rc<RefCell<Token>>) -> Result<()>;
    fn start_rule(&mut self, rule_type: RuleType) -> Result<()>;
    fn end_rule(&mut self, rule_type: RuleType) -> Result<()>;
    fn get_result(&mut self) -> Self::BuilderResult;
    fn reset(&mut self);
}

pub trait TokenScan {
    fn scan_next_token(&mut self) -> Result<Token>;
}

pub trait TokenMatch {
    fn match_eof(&mut self, token: &mut Token) -> Result<bool>;
    fn match_empty(&mut self, token: &mut Token) -> Result<bool>;
    fn match_comment(&mut self, token: &mut Token) -> Result<bool>;
    fn match_tag_line(&mut self, token: &mut Token) -> Result<bool>;
    fn match_feature_line(&mut self, token: &mut Token) -> Result<bool>;
    fn match_background_line(&mut self, token: &mut Token) -> Result<bool>;
    fn match_scenario_line(&mut self, token: &mut Token) -> Result<bool>;
    fn match_scenario_outline_line(&mut self, token: &mut Token) -> Result<bool>;
    fn match_examples_line(&mut self, token: &mut Token) -> Result<bool>;
    fn match_step_line(&mut self, token: &mut Token) -> Result<bool>;
    fn match_doc_string_separator(&mut self, token: &mut Token) -> Result<bool>;
    fn match_table_row(&mut self, token: &mut Token) -> Result<bool>;
    fn match_language(&mut self, token: &mut Token) -> Result<bool>;
    fn match_other(&mut self, token: &mut Token) -> Result<bool>;
    fn reset(&mut self);
}

pub trait GherkinDialectProvide {
    fn get_default_dialect(&self) -> Result<Arc<GherkinDialect>>;

    fn get_dialect(&self, language: &str, location: Option<Location>) -> Result<Arc<GherkinDialect>>;

    fn get_languages(&self) -> Vec<&String>;
}
