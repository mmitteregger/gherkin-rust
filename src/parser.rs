// This code was generated by Berp (https://github.com/gasparnagy/berp/).
//
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.

use std::collections::VecDeque;
use std::default::Default;
use std::fmt;
use std::io::Read;
use std::sync::Arc;

use crate::ast::Location;
use crate::ast_builder::AstBuilder;
use crate::error::{Error, Result};
use crate::gherkin_dialect::GherkinDialect;
use crate::token::Token;
use crate::token_matcher::TokenMatcher;
use crate::token_scanner::TokenScanner;

#[derive(Debug, PartialEq, Eq, Hash, Clone, Copy)]
pub enum TokenType {
    None,
    Eof,
    Empty,
    Comment,
    TagLine,
    FeatureLine,
    RuleLine,
    BackgroundLine,
    ScenarioLine,
    ExamplesLine,
    StepLine,
    DocStringSeparator,
    TableRow,
    Language,
    Other,
}

impl fmt::Display for TokenType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}

#[derive(Debug, PartialEq, Eq, Hash, Clone, Copy)]
#[rustfmt::skip] // simplifies the parser template
pub enum RuleType {
    None,
    Eof, // #EOF
    Empty, // #Empty
    Comment, // #Comment
    TagLine, // #TagLine
    FeatureLine, // #FeatureLine
    RuleLine, // #RuleLine
    BackgroundLine, // #BackgroundLine
    ScenarioLine, // #ScenarioLine
    ExamplesLine, // #ExamplesLine
    StepLine, // #StepLine
    DocStringSeparator, // #DocStringSeparator
    TableRow, // #TableRow
    Language, // #Language
    Other, // #Other
    GherkinDocument, // GherkinDocument! := Feature?
    Feature, // Feature! := FeatureHeader Background? ScenarioDefinition* Rule*
    FeatureHeader, // FeatureHeader! := #Language? Tags? #FeatureLine DescriptionHelper
    Rule, // Rule! := RuleHeader Background? ScenarioDefinition*
    RuleHeader, // RuleHeader! := #RuleLine DescriptionHelper
    Background, // Background! := #BackgroundLine DescriptionHelper Step*
    ScenarioDefinition, // ScenarioDefinition! := Tags? Scenario
    Scenario, // Scenario! := #ScenarioLine DescriptionHelper Step* ExamplesDefinition*
    ExamplesDefinition, // ExamplesDefinition! [#Empty|#Comment|#TagLine-&gt;#ExamplesLine] := Tags? Examples
    Examples, // Examples! := #ExamplesLine DescriptionHelper ExamplesTable?
    ExamplesTable, // ExamplesTable! := #TableRow #TableRow*
    Step, // Step! := #StepLine StepArg?
    StepArg, // StepArg := (DataTable | DocString)
    DataTable, // DataTable! := #TableRow+
    DocString, // DocString! := #DocStringSeparator #Other* #DocStringSeparator
    Tags, // Tags! := #TagLine+
    DescriptionHelper, // DescriptionHelper := #Empty* Description? #Comment*
    Description, // Description! := #Other+
}

impl fmt::Display for RuleType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}

impl From<TokenType> for RuleType {
    fn from(token_type: TokenType) -> RuleType {
        match token_type {
            TokenType::Eof => RuleType::Eof,
            TokenType::Empty => RuleType::Empty,
            TokenType::Comment => RuleType::Comment,
            TokenType::TagLine => RuleType::TagLine,
            TokenType::FeatureLine => RuleType::FeatureLine,
            TokenType::RuleLine => RuleType::RuleLine,
            TokenType::BackgroundLine => RuleType::BackgroundLine,
            TokenType::ScenarioLine => RuleType::ScenarioLine,
            TokenType::ExamplesLine => RuleType::ExamplesLine,
            TokenType::StepLine => RuleType::StepLine,
            TokenType::DocStringSeparator => RuleType::DocStringSeparator,
            TokenType::TableRow => RuleType::TableRow,
            TokenType::Language => RuleType::Language,
            TokenType::Other => RuleType::Other,
            _ => RuleType::Other,
        }
    }
}

pub struct Parser<B: Builder> {
    builder: B,
    token_match: Box<dyn TokenMatch>,
    stop_at_first_error: bool,
}

impl Default for Parser<AstBuilder> {
    fn default() -> Parser<AstBuilder> {
        ParserOptions::new().create()
    }
}

pub struct ParserOptions<B: Builder> {
    builder: B,
    token_match: Option<Box<dyn TokenMatch>>,
    stop_at_first_error: Option<bool>,
}

impl Default for ParserOptions<AstBuilder> {
    fn default() -> ParserOptions<AstBuilder> {
        ParserOptions {
            builder: AstBuilder::default(),
            token_match: None,
            stop_at_first_error: None,
        }
    }
}

impl ParserOptions<AstBuilder> {
    pub fn new() -> ParserOptions<AstBuilder> {
        ParserOptions::default()
    }
}

impl<B: Builder> ParserOptions<B> {
    pub fn with_builder(builder: B) -> ParserOptions<B> {
        ParserOptions {
            builder,
            token_match: None,
            stop_at_first_error: None,
        }
    }
}

impl<B: Builder> ParserOptions<B> {
    pub fn language<S>(self, language: S) -> ParserOptions<B>
    where
        S: Into<String>,
    {
        self.token_matcher(TokenMatcher::with_default_dialect_name(language))
    }

    pub fn dialect_provider<DP>(self, dialect_provider: DP) -> ParserOptions<B>
    where
        DP: GherkinDialectProvide + 'static,
    {
        self.token_matcher(TokenMatcher::with_dialect_provider(dialect_provider))
    }

    pub(crate) fn token_matcher<TM>(mut self, token_match: TM) -> ParserOptions<B>
    where
        TM: TokenMatch + 'static,
    {
        self.token_match = Some(Box::new(token_match));
        self
    }

    pub fn stop_at_first_error(mut self, stop_at_first_error: bool) -> ParserOptions<B> {
        self.stop_at_first_error = Some(stop_at_first_error);
        self
    }

    pub fn create(self) -> Parser<B> {
        Parser {
            builder: self.builder,
            token_match: self
                .token_match
                .unwrap_or_else(|| Box::new(TokenMatcher::default())),
            stop_at_first_error: self.stop_at_first_error.unwrap_or(false),
        }
    }
}

struct ParserContext<'a> {
    token_scan: &'a mut dyn TokenScan,
    token_queue: VecDeque<Token>,
    errors: Vec<Error>,
}

impl<B: Builder> Parser<B> {
    pub fn with_builder(builder: B) -> Parser<B> {
        ParserOptions::with_builder(builder).create()
    }

    pub fn parse_str<S: AsRef<str>>(&mut self, source: S) -> Result<B::BuilderResult> {
        self.parse(&mut TokenScanner::from(source.as_ref()))
    }

    pub fn parse_reader<R: Read>(&mut self, source: R) -> Result<B::BuilderResult> {
        self.parse(&mut TokenScanner::from(source))
    }

    fn parse<TS: TokenScan>(&mut self, token_scan: &mut TS) -> Result<B::BuilderResult> {
        self.builder.reset();
        self.token_match.reset();

        let mut context = ParserContext {
            token_scan,
            token_queue: VecDeque::new(),
            errors: Vec::new(),
        };

        self.start_rule(&mut context, RuleType::GherkinDocument)?;

        let mut token: Token;
        let mut token_is_eof;
        let mut state: u32 = 0;
        loop {
            match self.read_token(&mut context) {
                Ok(t) => token = t,
                Err(error) => {
                    self.add_error(&mut context, error);
                    if self.stop_at_first_error {
                        break;
                    }
                    continue;
                }
            };

            token_is_eof = token.is_eof();

            state = self.match_token(state, token, &mut context)?;

            if token_is_eof {
                break;
            }
        }

        self.end_rule(&mut context, RuleType::GherkinDocument)?;

        if !context.errors.is_empty() {
            return Err(Error::Composite(context.errors));
        }

        Ok(self.builder.get_result())
    }

    fn add_error(&mut self, context: &mut ParserContext<'_>, error: Error) {
        context.errors.push(error);
        // if (context.errors.size() > 10)
        //     throw new ParserException.CompositeParserException(context.errors);
    }

    fn handle_ast_result(
        &mut self,
        context: &mut ParserContext<'_>,
        result: Result<()>,
    ) -> Result<()> {
        self.handle_external_result(context, result, ())
    }

    fn handle_external_result<V>(
        &mut self,
        context: &mut ParserContext<'_>,
        result: Result<V>,
        default_value: V,
    ) -> Result<V> {
        if self.stop_at_first_error {
            return result;
        }

        match result {
            Ok(value) => return Ok(value),
            Err(error) => match error {
                Error::Composite(errors) => {
                    for parse_error in errors {
                        self.add_error(context, parse_error);
                    }
                }
                _ => self.add_error(context, error),
            },
        }

        Ok(default_value)
    }

    fn build(&mut self, context: &mut ParserContext<'_>, token: Token) -> Result<()> {
        let result = self.builder.build(token);
        self.handle_ast_result(context, result)
    }

    fn start_rule(&mut self, context: &mut ParserContext<'_>, rule_type: RuleType) -> Result<()> {
        let result = self.builder.start_rule(rule_type);
        self.handle_ast_result(context, result)
    }

    fn end_rule(&mut self, context: &mut ParserContext<'_>, rule_type: RuleType) -> Result<()> {
        let result = self.builder.end_rule(rule_type);
        self.handle_ast_result(context, result)
    }

    fn read_token(&mut self, context: &mut ParserContext<'_>) -> Result<Token> {
        match context.token_queue.pop_front() {
            Some(token) => Ok(token),
            None => context.token_scan.next(),
        }
    }

    #[rustfmt::skip] // because the generated lengths differ
    fn match_eof(
        &mut self,
        context: &mut ParserContext<'_>,
        token: &mut Token,
    ) -> Result<bool> {
        let result = self.token_match.match_eof(token);
        self.handle_external_result(context, result, false)
    }

    #[rustfmt::skip] // because the generated lengths differ
    fn match_empty(
        &mut self,
        context: &mut ParserContext<'_>,
        token: &mut Token,
    ) -> Result<bool> {
        if token.is_eof() {
            return Ok(false);
        };
        let result = self.token_match.match_empty(token);
        self.handle_external_result(context, result, false)
    }

    #[rustfmt::skip] // because the generated lengths differ
    fn match_comment(
        &mut self,
        context: &mut ParserContext<'_>,
        token: &mut Token,
    ) -> Result<bool> {
        if token.is_eof() {
            return Ok(false);
        };
        let result = self.token_match.match_comment(token);
        self.handle_external_result(context, result, false)
    }

    #[rustfmt::skip] // because the generated lengths differ
    fn match_tag_line(
        &mut self,
        context: &mut ParserContext<'_>,
        token: &mut Token,
    ) -> Result<bool> {
        if token.is_eof() {
            return Ok(false);
        };
        let result = self.token_match.match_tag_line(token);
        self.handle_external_result(context, result, false)
    }

    #[rustfmt::skip] // because the generated lengths differ
    fn match_feature_line(
        &mut self,
        context: &mut ParserContext<'_>,
        token: &mut Token,
    ) -> Result<bool> {
        if token.is_eof() {
            return Ok(false);
        };
        let result = self.token_match.match_feature_line(token);
        self.handle_external_result(context, result, false)
    }

    #[rustfmt::skip] // because the generated lengths differ
    fn match_rule_line(
        &mut self,
        context: &mut ParserContext<'_>,
        token: &mut Token,
    ) -> Result<bool> {
        if token.is_eof() {
            return Ok(false);
        };
        let result = self.token_match.match_rule_line(token);
        self.handle_external_result(context, result, false)
    }

    #[rustfmt::skip] // because the generated lengths differ
    fn match_background_line(
        &mut self,
        context: &mut ParserContext<'_>,
        token: &mut Token,
    ) -> Result<bool> {
        if token.is_eof() {
            return Ok(false);
        };
        let result = self.token_match.match_background_line(token);
        self.handle_external_result(context, result, false)
    }

    #[rustfmt::skip] // because the generated lengths differ
    fn match_scenario_line(
        &mut self,
        context: &mut ParserContext<'_>,
        token: &mut Token,
    ) -> Result<bool> {
        if token.is_eof() {
            return Ok(false);
        };
        let result = self.token_match.match_scenario_line(token);
        self.handle_external_result(context, result, false)
    }

    #[rustfmt::skip] // because the generated lengths differ
    fn match_examples_line(
        &mut self,
        context: &mut ParserContext<'_>,
        token: &mut Token,
    ) -> Result<bool> {
        if token.is_eof() {
            return Ok(false);
        };
        let result = self.token_match.match_examples_line(token);
        self.handle_external_result(context, result, false)
    }

    #[rustfmt::skip] // because the generated lengths differ
    fn match_step_line(
        &mut self,
        context: &mut ParserContext<'_>,
        token: &mut Token,
    ) -> Result<bool> {
        if token.is_eof() {
            return Ok(false);
        };
        let result = self.token_match.match_step_line(token);
        self.handle_external_result(context, result, false)
    }

    #[rustfmt::skip] // because the generated lengths differ
    fn match_doc_string_separator(
        &mut self,
        context: &mut ParserContext<'_>,
        token: &mut Token,
    ) -> Result<bool> {
        if token.is_eof() {
            return Ok(false);
        };
        let result = self.token_match.match_doc_string_separator(token);
        self.handle_external_result(context, result, false)
    }

    #[rustfmt::skip] // because the generated lengths differ
    fn match_table_row(
        &mut self,
        context: &mut ParserContext<'_>,
        token: &mut Token,
    ) -> Result<bool> {
        if token.is_eof() {
            return Ok(false);
        };
        let result = self.token_match.match_table_row(token);
        self.handle_external_result(context, result, false)
    }

    #[rustfmt::skip] // because the generated lengths differ
    fn match_language(
        &mut self,
        context: &mut ParserContext<'_>,
        token: &mut Token,
    ) -> Result<bool> {
        if token.is_eof() {
            return Ok(false);
        };
        let result = self.token_match.match_language(token);
        self.handle_external_result(context, result, false)
    }

    #[rustfmt::skip] // because the generated lengths differ
    fn match_other(
        &mut self,
        context: &mut ParserContext<'_>,
        token: &mut Token,
    ) -> Result<bool> {
        if token.is_eof() {
            return Ok(false);
        };
        let result = self.token_match.match_other(token);
        self.handle_external_result(context, result, false)
    }

    fn match_token(
        &mut self,
        state: u32,
        token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        match state {
            0 => self.match_token_at_0(token, context),
            1 => self.match_token_at_1(token, context),
            2 => self.match_token_at_2(token, context),
            3 => self.match_token_at_3(token, context),
            4 => self.match_token_at_4(token, context),
            5 => self.match_token_at_5(token, context),
            6 => self.match_token_at_6(token, context),
            7 => self.match_token_at_7(token, context),
            8 => self.match_token_at_8(token, context),
            9 => self.match_token_at_9(token, context),
            10 => self.match_token_at_10(token, context),
            11 => self.match_token_at_11(token, context),
            12 => self.match_token_at_12(token, context),
            13 => self.match_token_at_13(token, context),
            14 => self.match_token_at_14(token, context),
            15 => self.match_token_at_15(token, context),
            16 => self.match_token_at_16(token, context),
            17 => self.match_token_at_17(token, context),
            18 => self.match_token_at_18(token, context),
            19 => self.match_token_at_19(token, context),
            20 => self.match_token_at_20(token, context),
            21 => self.match_token_at_21(token, context),
            22 => self.match_token_at_22(token, context),
            23 => self.match_token_at_23(token, context),
            24 => self.match_token_at_24(token, context),
            25 => self.match_token_at_25(token, context),
            26 => self.match_token_at_26(token, context),
            27 => self.match_token_at_27(token, context),
            28 => self.match_token_at_28(token, context),
            29 => self.match_token_at_29(token, context),
            30 => self.match_token_at_30(token, context),
            31 => self.match_token_at_31(token, context),
            32 => self.match_token_at_32(token, context),
            33 => self.match_token_at_33(token, context),
            34 => self.match_token_at_34(token, context),
            35 => self.match_token_at_35(token, context),
            36 => self.match_token_at_36(token, context),
            37 => self.match_token_at_37(token, context),
            38 => self.match_token_at_38(token, context),
            39 => self.match_token_at_39(token, context),
            40 => self.match_token_at_40(token, context),
            42 => self.match_token_at_42(token, context),
            43 => self.match_token_at_43(token, context),
            44 => self.match_token_at_44(token, context),
            45 => self.match_token_at_45(token, context),
            46 => self.match_token_at_46(token, context),
            47 => self.match_token_at_47(token, context),
            48 => self.match_token_at_48(token, context),
            49 => self.match_token_at_49(token, context),
            _ => panic!("Unknown state: {}", state),
        }
    }

    // Start
    fn match_token_at_0(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_eof(context, &mut token)? {
            self.build(context, token)?;
            return Ok(41);
        }
        if self.match_language(context, &mut token)? {
            self.start_rule(context, RuleType::Feature)?;
            self.start_rule(context, RuleType::FeatureHeader)?;
            self.build(context, token)?;
            return Ok(1);
        }
        if self.match_tag_line(context, &mut token)? {
            self.start_rule(context, RuleType::Feature)?;
            self.start_rule(context, RuleType::FeatureHeader)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(2);
        }
        if self.match_feature_line(context, &mut token)? {
            self.start_rule(context, RuleType::Feature)?;
            self.start_rule(context, RuleType::FeatureHeader)?;
            self.build(context, token)?;
            return Ok(3);
        }
        if self.match_comment(context, &mut token)? {
            self.build(context, token)?;
            return Ok(0);
        }
        if self.match_empty(context, &mut token)? {
            self.build(context, token)?;
            return Ok(0);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 0 - Start");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#Language"),
            String::from("#TagLine"),
            String::from("#FeatureLine"),
            String::from("#Comment"),
            String::from("#Empty"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(0)
    }

    // GherkinDocument:0>Feature:0>FeatureHeader:0>#Language:0
    fn match_token_at_1(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_tag_line(context, &mut token)? {
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(2);
        }
        if self.match_feature_line(context, &mut token)? {
            self.build(context, token)?;
            return Ok(3);
        }
        if self.match_comment(context, &mut token)? {
            self.build(context, token)?;
            return Ok(1);
        }
        if self.match_empty(context, &mut token)? {
            self.build(context, token)?;
            return Ok(1);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 1 - GherkinDocument:0>Feature:0>FeatureHeader:0>#Language:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#TagLine"),
            String::from("#FeatureLine"),
            String::from("#Comment"),
            String::from("#Empty"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(1)
    }

    // GherkinDocument:0>Feature:0>FeatureHeader:1>Tags:0>#TagLine:0
    fn match_token_at_2(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_tag_line(context, &mut token)? {
            self.build(context, token)?;
            return Ok(2);
        }
        if self.match_feature_line(context, &mut token)? {
            self.end_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(3);
        }
        if self.match_comment(context, &mut token)? {
            self.build(context, token)?;
            return Ok(2);
        }
        if self.match_empty(context, &mut token)? {
            self.build(context, token)?;
            return Ok(2);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 2 - GherkinDocument:0>Feature:0>FeatureHeader:1>Tags:0>#TagLine:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#TagLine"),
            String::from("#FeatureLine"),
            String::from("#Comment"),
            String::from("#Empty"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(2)
    }

    // GherkinDocument:0>Feature:0>FeatureHeader:2>#FeatureLine:0
    fn match_token_at_3(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_eof(context, &mut token)? {
            self.end_rule(context, RuleType::FeatureHeader)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(41);
        }
        if self.match_empty(context, &mut token)? {
            self.build(context, token)?;
            return Ok(3);
        }
        if self.match_comment(context, &mut token)? {
            self.build(context, token)?;
            return Ok(5);
        }
        if self.match_background_line(context, &mut token)? {
            self.end_rule(context, RuleType::FeatureHeader)?;
            self.start_rule(context, RuleType::Background)?;
            self.build(context, token)?;
            return Ok(6);
        }
        if self.match_tag_line(context, &mut token)? {
            self.end_rule(context, RuleType::FeatureHeader)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_scenario_line(context, &mut token)? {
            self.end_rule(context, RuleType::FeatureHeader)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_rule_line(context, &mut token)? {
            self.end_rule(context, RuleType::FeatureHeader)?;
            self.start_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::RuleHeader)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_other(context, &mut token)? {
            self.start_rule(context, RuleType::Description)?;
            self.build(context, token)?;
            return Ok(4);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 3 - GherkinDocument:0>Feature:0>FeatureHeader:2>#FeatureLine:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#Empty"),
            String::from("#Comment"),
            String::from("#BackgroundLine"),
            String::from("#TagLine"),
            String::from("#ScenarioLine"),
            String::from("#RuleLine"),
            String::from("#Other"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(3)
    }

    // GherkinDocument:0>Feature:0>FeatureHeader:3>DescriptionHelper:1>Description:0>#Other:0
    fn match_token_at_4(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_eof(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::FeatureHeader)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(41);
        }
        if self.match_comment(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.build(context, token)?;
            return Ok(5);
        }
        if self.match_background_line(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::FeatureHeader)?;
            self.start_rule(context, RuleType::Background)?;
            self.build(context, token)?;
            return Ok(6);
        }
        if self.match_tag_line(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::FeatureHeader)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_scenario_line(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::FeatureHeader)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_rule_line(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::FeatureHeader)?;
            self.start_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::RuleHeader)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_other(context, &mut token)? {
            self.build(context, token)?;
            return Ok(4);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 4 - GherkinDocument:0>Feature:0>FeatureHeader:3>DescriptionHelper:1>Description:0>#Other:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#Comment"),
            String::from("#BackgroundLine"),
            String::from("#TagLine"),
            String::from("#ScenarioLine"),
            String::from("#RuleLine"),
            String::from("#Other"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(4)
    }

    // GherkinDocument:0>Feature:0>FeatureHeader:3>DescriptionHelper:2>#Comment:0
    fn match_token_at_5(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_eof(context, &mut token)? {
            self.end_rule(context, RuleType::FeatureHeader)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(41);
        }
        if self.match_comment(context, &mut token)? {
            self.build(context, token)?;
            return Ok(5);
        }
        if self.match_background_line(context, &mut token)? {
            self.end_rule(context, RuleType::FeatureHeader)?;
            self.start_rule(context, RuleType::Background)?;
            self.build(context, token)?;
            return Ok(6);
        }
        if self.match_tag_line(context, &mut token)? {
            self.end_rule(context, RuleType::FeatureHeader)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_scenario_line(context, &mut token)? {
            self.end_rule(context, RuleType::FeatureHeader)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_rule_line(context, &mut token)? {
            self.end_rule(context, RuleType::FeatureHeader)?;
            self.start_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::RuleHeader)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_empty(context, &mut token)? {
            self.build(context, token)?;
            return Ok(5);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 5 - GherkinDocument:0>Feature:0>FeatureHeader:3>DescriptionHelper:2>#Comment:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#Comment"),
            String::from("#BackgroundLine"),
            String::from("#TagLine"),
            String::from("#ScenarioLine"),
            String::from("#RuleLine"),
            String::from("#Empty"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(5)
    }

    // GherkinDocument:0>Feature:1>Background:0>#BackgroundLine:0
    fn match_token_at_6(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_eof(context, &mut token)? {
            self.end_rule(context, RuleType::Background)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(41);
        }
        if self.match_empty(context, &mut token)? {
            self.build(context, token)?;
            return Ok(6);
        }
        if self.match_comment(context, &mut token)? {
            self.build(context, token)?;
            return Ok(8);
        }
        if self.match_step_line(context, &mut token)? {
            self.start_rule(context, RuleType::Step)?;
            self.build(context, token)?;
            return Ok(9);
        }
        if self.match_tag_line(context, &mut token)? {
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_scenario_line(context, &mut token)? {
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_rule_line(context, &mut token)? {
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::RuleHeader)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_other(context, &mut token)? {
            self.start_rule(context, RuleType::Description)?;
            self.build(context, token)?;
            return Ok(7);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 6 - GherkinDocument:0>Feature:1>Background:0>#BackgroundLine:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#Empty"),
            String::from("#Comment"),
            String::from("#StepLine"),
            String::from("#TagLine"),
            String::from("#ScenarioLine"),
            String::from("#RuleLine"),
            String::from("#Other"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(6)
    }

    // GherkinDocument:0>Feature:1>Background:1>DescriptionHelper:1>Description:0>#Other:0
    fn match_token_at_7(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_eof(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::Background)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(41);
        }
        if self.match_comment(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.build(context, token)?;
            return Ok(8);
        }
        if self.match_step_line(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.start_rule(context, RuleType::Step)?;
            self.build(context, token)?;
            return Ok(9);
        }
        if self.match_tag_line(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_scenario_line(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_rule_line(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::RuleHeader)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_other(context, &mut token)? {
            self.build(context, token)?;
            return Ok(7);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 7 - GherkinDocument:0>Feature:1>Background:1>DescriptionHelper:1>Description:0>#Other:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#Comment"),
            String::from("#StepLine"),
            String::from("#TagLine"),
            String::from("#ScenarioLine"),
            String::from("#RuleLine"),
            String::from("#Other"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(7)
    }

    // GherkinDocument:0>Feature:1>Background:1>DescriptionHelper:2>#Comment:0
    fn match_token_at_8(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_eof(context, &mut token)? {
            self.end_rule(context, RuleType::Background)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(41);
        }
        if self.match_comment(context, &mut token)? {
            self.build(context, token)?;
            return Ok(8);
        }
        if self.match_step_line(context, &mut token)? {
            self.start_rule(context, RuleType::Step)?;
            self.build(context, token)?;
            return Ok(9);
        }
        if self.match_tag_line(context, &mut token)? {
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_scenario_line(context, &mut token)? {
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_rule_line(context, &mut token)? {
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::RuleHeader)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_empty(context, &mut token)? {
            self.build(context, token)?;
            return Ok(8);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 8 - GherkinDocument:0>Feature:1>Background:1>DescriptionHelper:2>#Comment:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#Comment"),
            String::from("#StepLine"),
            String::from("#TagLine"),
            String::from("#ScenarioLine"),
            String::from("#RuleLine"),
            String::from("#Empty"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(8)
    }

    // GherkinDocument:0>Feature:1>Background:2>Step:0>#StepLine:0
    fn match_token_at_9(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_eof(context, &mut token)? {
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Background)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(41);
        }
        if self.match_table_row(context, &mut token)? {
            self.start_rule(context, RuleType::DataTable)?;
            self.build(context, token)?;
            return Ok(10);
        }
        if self.match_doc_string_separator(context, &mut token)? {
            self.start_rule(context, RuleType::DocString)?;
            self.build(context, token)?;
            return Ok(48);
        }
        if self.match_step_line(context, &mut token)? {
            self.end_rule(context, RuleType::Step)?;
            self.start_rule(context, RuleType::Step)?;
            self.build(context, token)?;
            return Ok(9);
        }
        if self.match_tag_line(context, &mut token)? {
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_scenario_line(context, &mut token)? {
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_rule_line(context, &mut token)? {
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::RuleHeader)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_comment(context, &mut token)? {
            self.build(context, token)?;
            return Ok(9);
        }
        if self.match_empty(context, &mut token)? {
            self.build(context, token)?;
            return Ok(9);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 9 - GherkinDocument:0>Feature:1>Background:2>Step:0>#StepLine:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#TableRow"),
            String::from("#DocStringSeparator"),
            String::from("#StepLine"),
            String::from("#TagLine"),
            String::from("#ScenarioLine"),
            String::from("#RuleLine"),
            String::from("#Comment"),
            String::from("#Empty"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(9)
    }

    // GherkinDocument:0>Feature:1>Background:2>Step:1>StepArg:0>__alt0:0>DataTable:0>#TableRow:0
    fn match_token_at_10(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_eof(context, &mut token)? {
            self.end_rule(context, RuleType::DataTable)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Background)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(41);
        }
        if self.match_table_row(context, &mut token)? {
            self.build(context, token)?;
            return Ok(10);
        }
        if self.match_step_line(context, &mut token)? {
            self.end_rule(context, RuleType::DataTable)?;
            self.end_rule(context, RuleType::Step)?;
            self.start_rule(context, RuleType::Step)?;
            self.build(context, token)?;
            return Ok(9);
        }
        if self.match_tag_line(context, &mut token)? {
            self.end_rule(context, RuleType::DataTable)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_scenario_line(context, &mut token)? {
            self.end_rule(context, RuleType::DataTable)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_rule_line(context, &mut token)? {
            self.end_rule(context, RuleType::DataTable)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::RuleHeader)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_comment(context, &mut token)? {
            self.build(context, token)?;
            return Ok(10);
        }
        if self.match_empty(context, &mut token)? {
            self.build(context, token)?;
            return Ok(10);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 10 - GherkinDocument:0>Feature:1>Background:2>Step:1>StepArg:0>__alt0:0>DataTable:0>#TableRow:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#TableRow"),
            String::from("#StepLine"),
            String::from("#TagLine"),
            String::from("#ScenarioLine"),
            String::from("#RuleLine"),
            String::from("#Comment"),
            String::from("#Empty"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(10)
    }

    // GherkinDocument:0>Feature:2>ScenarioDefinition:0>Tags:0>#TagLine:0
    fn match_token_at_11(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_tag_line(context, &mut token)? {
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_scenario_line(context, &mut token)? {
            self.end_rule(context, RuleType::Tags)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_comment(context, &mut token)? {
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_empty(context, &mut token)? {
            self.build(context, token)?;
            return Ok(11);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 11 - GherkinDocument:0>Feature:2>ScenarioDefinition:0>Tags:0>#TagLine:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#TagLine"),
            String::from("#ScenarioLine"),
            String::from("#Comment"),
            String::from("#Empty"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(11)
    }

    // GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:0>#ScenarioLine:0
    fn match_token_at_12(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_eof(context, &mut token)? {
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(41);
        }
        if self.match_empty(context, &mut token)? {
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_comment(context, &mut token)? {
            self.build(context, token)?;
            return Ok(14);
        }
        if self.match_step_line(context, &mut token)? {
            self.start_rule(context, RuleType::Step)?;
            self.build(context, token)?;
            return Ok(15);
        }
        let match_tag_line_with_lookahead =
            { self.match_tag_line(context, &mut token)? && self.lookahead_0(context, &token) };
        if match_tag_line_with_lookahead {
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(17);
        }
        if self.match_tag_line(context, &mut token)? {
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_examples_line(context, &mut token)? {
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Examples)?;
            self.build(context, token)?;
            return Ok(18);
        }
        if self.match_scenario_line(context, &mut token)? {
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_rule_line(context, &mut token)? {
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::RuleHeader)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_other(context, &mut token)? {
            self.start_rule(context, RuleType::Description)?;
            self.build(context, token)?;
            return Ok(13);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 12 - GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:0>#ScenarioLine:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#Empty"),
            String::from("#Comment"),
            String::from("#StepLine"),
            String::from("#TagLine"),
            String::from("#ExamplesLine"),
            String::from("#ScenarioLine"),
            String::from("#RuleLine"),
            String::from("#Other"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(12)
    }

    // GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:1>DescriptionHelper:1>Description:0>#Other:0
    fn match_token_at_13(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_eof(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(41);
        }
        if self.match_comment(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.build(context, token)?;
            return Ok(14);
        }
        if self.match_step_line(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.start_rule(context, RuleType::Step)?;
            self.build(context, token)?;
            return Ok(15);
        }
        let match_tag_line_with_lookahead =
            { self.match_tag_line(context, &mut token)? && self.lookahead_0(context, &token) };
        if match_tag_line_with_lookahead {
            self.end_rule(context, RuleType::Description)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(17);
        }
        if self.match_tag_line(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_examples_line(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Examples)?;
            self.build(context, token)?;
            return Ok(18);
        }
        if self.match_scenario_line(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_rule_line(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::RuleHeader)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_other(context, &mut token)? {
            self.build(context, token)?;
            return Ok(13);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 13 - GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:1>DescriptionHelper:1>Description:0>#Other:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#Comment"),
            String::from("#StepLine"),
            String::from("#TagLine"),
            String::from("#ExamplesLine"),
            String::from("#ScenarioLine"),
            String::from("#RuleLine"),
            String::from("#Other"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(13)
    }

    // GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:1>DescriptionHelper:2>#Comment:0
    fn match_token_at_14(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_eof(context, &mut token)? {
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(41);
        }
        if self.match_comment(context, &mut token)? {
            self.build(context, token)?;
            return Ok(14);
        }
        if self.match_step_line(context, &mut token)? {
            self.start_rule(context, RuleType::Step)?;
            self.build(context, token)?;
            return Ok(15);
        }
        let match_tag_line_with_lookahead =
            { self.match_tag_line(context, &mut token)? && self.lookahead_0(context, &token) };
        if match_tag_line_with_lookahead {
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(17);
        }
        if self.match_tag_line(context, &mut token)? {
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_examples_line(context, &mut token)? {
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Examples)?;
            self.build(context, token)?;
            return Ok(18);
        }
        if self.match_scenario_line(context, &mut token)? {
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_rule_line(context, &mut token)? {
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::RuleHeader)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_empty(context, &mut token)? {
            self.build(context, token)?;
            return Ok(14);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 14 - GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:1>DescriptionHelper:2>#Comment:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#Comment"),
            String::from("#StepLine"),
            String::from("#TagLine"),
            String::from("#ExamplesLine"),
            String::from("#ScenarioLine"),
            String::from("#RuleLine"),
            String::from("#Empty"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(14)
    }

    // GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:2>Step:0>#StepLine:0
    fn match_token_at_15(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_eof(context, &mut token)? {
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(41);
        }
        if self.match_table_row(context, &mut token)? {
            self.start_rule(context, RuleType::DataTable)?;
            self.build(context, token)?;
            return Ok(16);
        }
        if self.match_doc_string_separator(context, &mut token)? {
            self.start_rule(context, RuleType::DocString)?;
            self.build(context, token)?;
            return Ok(46);
        }
        if self.match_step_line(context, &mut token)? {
            self.end_rule(context, RuleType::Step)?;
            self.start_rule(context, RuleType::Step)?;
            self.build(context, token)?;
            return Ok(15);
        }
        let match_tag_line_with_lookahead =
            { self.match_tag_line(context, &mut token)? && self.lookahead_0(context, &token) };
        if match_tag_line_with_lookahead {
            self.end_rule(context, RuleType::Step)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(17);
        }
        if self.match_tag_line(context, &mut token)? {
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_examples_line(context, &mut token)? {
            self.end_rule(context, RuleType::Step)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Examples)?;
            self.build(context, token)?;
            return Ok(18);
        }
        if self.match_scenario_line(context, &mut token)? {
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_rule_line(context, &mut token)? {
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::RuleHeader)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_comment(context, &mut token)? {
            self.build(context, token)?;
            return Ok(15);
        }
        if self.match_empty(context, &mut token)? {
            self.build(context, token)?;
            return Ok(15);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 15 - GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:2>Step:0>#StepLine:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#TableRow"),
            String::from("#DocStringSeparator"),
            String::from("#StepLine"),
            String::from("#TagLine"),
            String::from("#ExamplesLine"),
            String::from("#ScenarioLine"),
            String::from("#RuleLine"),
            String::from("#Comment"),
            String::from("#Empty"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(15)
    }

    // GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:2>Step:1>StepArg:0>__alt0:0>DataTable:0>#TableRow:0
    fn match_token_at_16(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_eof(context, &mut token)? {
            self.end_rule(context, RuleType::DataTable)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(41);
        }
        if self.match_table_row(context, &mut token)? {
            self.build(context, token)?;
            return Ok(16);
        }
        if self.match_step_line(context, &mut token)? {
            self.end_rule(context, RuleType::DataTable)?;
            self.end_rule(context, RuleType::Step)?;
            self.start_rule(context, RuleType::Step)?;
            self.build(context, token)?;
            return Ok(15);
        }
        let match_tag_line_with_lookahead =
            { self.match_tag_line(context, &mut token)? && self.lookahead_0(context, &token) };
        if match_tag_line_with_lookahead {
            self.end_rule(context, RuleType::DataTable)?;
            self.end_rule(context, RuleType::Step)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(17);
        }
        if self.match_tag_line(context, &mut token)? {
            self.end_rule(context, RuleType::DataTable)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_examples_line(context, &mut token)? {
            self.end_rule(context, RuleType::DataTable)?;
            self.end_rule(context, RuleType::Step)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Examples)?;
            self.build(context, token)?;
            return Ok(18);
        }
        if self.match_scenario_line(context, &mut token)? {
            self.end_rule(context, RuleType::DataTable)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_rule_line(context, &mut token)? {
            self.end_rule(context, RuleType::DataTable)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::RuleHeader)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_comment(context, &mut token)? {
            self.build(context, token)?;
            return Ok(16);
        }
        if self.match_empty(context, &mut token)? {
            self.build(context, token)?;
            return Ok(16);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 16 - GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:2>Step:1>StepArg:0>__alt0:0>DataTable:0>#TableRow:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#TableRow"),
            String::from("#StepLine"),
            String::from("#TagLine"),
            String::from("#ExamplesLine"),
            String::from("#ScenarioLine"),
            String::from("#RuleLine"),
            String::from("#Comment"),
            String::from("#Empty"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(16)
    }

    // GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:3>ExamplesDefinition:0>Tags:0>#TagLine:0
    fn match_token_at_17(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_tag_line(context, &mut token)? {
            self.build(context, token)?;
            return Ok(17);
        }
        if self.match_examples_line(context, &mut token)? {
            self.end_rule(context, RuleType::Tags)?;
            self.start_rule(context, RuleType::Examples)?;
            self.build(context, token)?;
            return Ok(18);
        }
        if self.match_comment(context, &mut token)? {
            self.build(context, token)?;
            return Ok(17);
        }
        if self.match_empty(context, &mut token)? {
            self.build(context, token)?;
            return Ok(17);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 17 - GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:3>ExamplesDefinition:0>Tags:0>#TagLine:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#TagLine"),
            String::from("#ExamplesLine"),
            String::from("#Comment"),
            String::from("#Empty"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(17)
    }

    // GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:3>ExamplesDefinition:1>Examples:0>#ExamplesLine:0
    fn match_token_at_18(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_eof(context, &mut token)? {
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(41);
        }
        if self.match_empty(context, &mut token)? {
            self.build(context, token)?;
            return Ok(18);
        }
        if self.match_comment(context, &mut token)? {
            self.build(context, token)?;
            return Ok(20);
        }
        if self.match_table_row(context, &mut token)? {
            self.start_rule(context, RuleType::ExamplesTable)?;
            self.build(context, token)?;
            return Ok(21);
        }
        let match_tag_line_with_lookahead =
            { self.match_tag_line(context, &mut token)? && self.lookahead_0(context, &token) };
        if match_tag_line_with_lookahead {
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(17);
        }
        if self.match_tag_line(context, &mut token)? {
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_examples_line(context, &mut token)? {
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Examples)?;
            self.build(context, token)?;
            return Ok(18);
        }
        if self.match_scenario_line(context, &mut token)? {
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_rule_line(context, &mut token)? {
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::RuleHeader)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_other(context, &mut token)? {
            self.start_rule(context, RuleType::Description)?;
            self.build(context, token)?;
            return Ok(19);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 18 - GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:3>ExamplesDefinition:1>Examples:0>#ExamplesLine:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#Empty"),
            String::from("#Comment"),
            String::from("#TableRow"),
            String::from("#TagLine"),
            String::from("#ExamplesLine"),
            String::from("#ScenarioLine"),
            String::from("#RuleLine"),
            String::from("#Other"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(18)
    }

    // GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:3>ExamplesDefinition:1>Examples:1>DescriptionHelper:1>Description:0>#Other:0
    fn match_token_at_19(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_eof(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(41);
        }
        if self.match_comment(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.build(context, token)?;
            return Ok(20);
        }
        if self.match_table_row(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.start_rule(context, RuleType::ExamplesTable)?;
            self.build(context, token)?;
            return Ok(21);
        }
        let match_tag_line_with_lookahead =
            { self.match_tag_line(context, &mut token)? && self.lookahead_0(context, &token) };
        if match_tag_line_with_lookahead {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(17);
        }
        if self.match_tag_line(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_examples_line(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Examples)?;
            self.build(context, token)?;
            return Ok(18);
        }
        if self.match_scenario_line(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_rule_line(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::RuleHeader)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_other(context, &mut token)? {
            self.build(context, token)?;
            return Ok(19);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 19 - GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:3>ExamplesDefinition:1>Examples:1>DescriptionHelper:1>Description:0>#Other:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#Comment"),
            String::from("#TableRow"),
            String::from("#TagLine"),
            String::from("#ExamplesLine"),
            String::from("#ScenarioLine"),
            String::from("#RuleLine"),
            String::from("#Other"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(19)
    }

    // GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:3>ExamplesDefinition:1>Examples:1>DescriptionHelper:2>#Comment:0
    fn match_token_at_20(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_eof(context, &mut token)? {
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(41);
        }
        if self.match_comment(context, &mut token)? {
            self.build(context, token)?;
            return Ok(20);
        }
        if self.match_table_row(context, &mut token)? {
            self.start_rule(context, RuleType::ExamplesTable)?;
            self.build(context, token)?;
            return Ok(21);
        }
        let match_tag_line_with_lookahead =
            { self.match_tag_line(context, &mut token)? && self.lookahead_0(context, &token) };
        if match_tag_line_with_lookahead {
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(17);
        }
        if self.match_tag_line(context, &mut token)? {
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_examples_line(context, &mut token)? {
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Examples)?;
            self.build(context, token)?;
            return Ok(18);
        }
        if self.match_scenario_line(context, &mut token)? {
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_rule_line(context, &mut token)? {
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::RuleHeader)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_empty(context, &mut token)? {
            self.build(context, token)?;
            return Ok(20);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 20 - GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:3>ExamplesDefinition:1>Examples:1>DescriptionHelper:2>#Comment:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#Comment"),
            String::from("#TableRow"),
            String::from("#TagLine"),
            String::from("#ExamplesLine"),
            String::from("#ScenarioLine"),
            String::from("#RuleLine"),
            String::from("#Empty"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(20)
    }

    // GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:3>ExamplesDefinition:1>Examples:2>ExamplesTable:0>#TableRow:0
    fn match_token_at_21(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_eof(context, &mut token)? {
            self.end_rule(context, RuleType::ExamplesTable)?;
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(41);
        }
        if self.match_table_row(context, &mut token)? {
            self.build(context, token)?;
            return Ok(21);
        }
        let match_tag_line_with_lookahead =
            { self.match_tag_line(context, &mut token)? && self.lookahead_0(context, &token) };
        if match_tag_line_with_lookahead {
            self.end_rule(context, RuleType::ExamplesTable)?;
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(17);
        }
        if self.match_tag_line(context, &mut token)? {
            self.end_rule(context, RuleType::ExamplesTable)?;
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_examples_line(context, &mut token)? {
            self.end_rule(context, RuleType::ExamplesTable)?;
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Examples)?;
            self.build(context, token)?;
            return Ok(18);
        }
        if self.match_scenario_line(context, &mut token)? {
            self.end_rule(context, RuleType::ExamplesTable)?;
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_rule_line(context, &mut token)? {
            self.end_rule(context, RuleType::ExamplesTable)?;
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::RuleHeader)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_comment(context, &mut token)? {
            self.build(context, token)?;
            return Ok(21);
        }
        if self.match_empty(context, &mut token)? {
            self.build(context, token)?;
            return Ok(21);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 21 - GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:3>ExamplesDefinition:1>Examples:2>ExamplesTable:0>#TableRow:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#TableRow"),
            String::from("#TagLine"),
            String::from("#ExamplesLine"),
            String::from("#ScenarioLine"),
            String::from("#RuleLine"),
            String::from("#Comment"),
            String::from("#Empty"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(21)
    }

    // GherkinDocument:0>Feature:3>Rule:0>RuleHeader:0>#RuleLine:0
    fn match_token_at_22(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_eof(context, &mut token)? {
            self.end_rule(context, RuleType::RuleHeader)?;
            self.end_rule(context, RuleType::Rule)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(41);
        }
        if self.match_empty(context, &mut token)? {
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_comment(context, &mut token)? {
            self.build(context, token)?;
            return Ok(24);
        }
        if self.match_background_line(context, &mut token)? {
            self.end_rule(context, RuleType::RuleHeader)?;
            self.start_rule(context, RuleType::Background)?;
            self.build(context, token)?;
            return Ok(25);
        }
        if self.match_tag_line(context, &mut token)? {
            self.end_rule(context, RuleType::RuleHeader)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(30);
        }
        if self.match_scenario_line(context, &mut token)? {
            self.end_rule(context, RuleType::RuleHeader)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(31);
        }
        if self.match_rule_line(context, &mut token)? {
            self.end_rule(context, RuleType::RuleHeader)?;
            self.end_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::RuleHeader)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_other(context, &mut token)? {
            self.start_rule(context, RuleType::Description)?;
            self.build(context, token)?;
            return Ok(23);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 22 - GherkinDocument:0>Feature:3>Rule:0>RuleHeader:0>#RuleLine:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#Empty"),
            String::from("#Comment"),
            String::from("#BackgroundLine"),
            String::from("#TagLine"),
            String::from("#ScenarioLine"),
            String::from("#RuleLine"),
            String::from("#Other"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(22)
    }

    // GherkinDocument:0>Feature:3>Rule:0>RuleHeader:1>DescriptionHelper:1>Description:0>#Other:0
    fn match_token_at_23(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_eof(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::RuleHeader)?;
            self.end_rule(context, RuleType::Rule)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(41);
        }
        if self.match_comment(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.build(context, token)?;
            return Ok(24);
        }
        if self.match_background_line(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::RuleHeader)?;
            self.start_rule(context, RuleType::Background)?;
            self.build(context, token)?;
            return Ok(25);
        }
        if self.match_tag_line(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::RuleHeader)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(30);
        }
        if self.match_scenario_line(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::RuleHeader)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(31);
        }
        if self.match_rule_line(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::RuleHeader)?;
            self.end_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::RuleHeader)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_other(context, &mut token)? {
            self.build(context, token)?;
            return Ok(23);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 23 - GherkinDocument:0>Feature:3>Rule:0>RuleHeader:1>DescriptionHelper:1>Description:0>#Other:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#Comment"),
            String::from("#BackgroundLine"),
            String::from("#TagLine"),
            String::from("#ScenarioLine"),
            String::from("#RuleLine"),
            String::from("#Other"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(23)
    }

    // GherkinDocument:0>Feature:3>Rule:0>RuleHeader:1>DescriptionHelper:2>#Comment:0
    fn match_token_at_24(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_eof(context, &mut token)? {
            self.end_rule(context, RuleType::RuleHeader)?;
            self.end_rule(context, RuleType::Rule)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(41);
        }
        if self.match_comment(context, &mut token)? {
            self.build(context, token)?;
            return Ok(24);
        }
        if self.match_background_line(context, &mut token)? {
            self.end_rule(context, RuleType::RuleHeader)?;
            self.start_rule(context, RuleType::Background)?;
            self.build(context, token)?;
            return Ok(25);
        }
        if self.match_tag_line(context, &mut token)? {
            self.end_rule(context, RuleType::RuleHeader)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(30);
        }
        if self.match_scenario_line(context, &mut token)? {
            self.end_rule(context, RuleType::RuleHeader)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(31);
        }
        if self.match_rule_line(context, &mut token)? {
            self.end_rule(context, RuleType::RuleHeader)?;
            self.end_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::RuleHeader)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_empty(context, &mut token)? {
            self.build(context, token)?;
            return Ok(24);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 24 - GherkinDocument:0>Feature:3>Rule:0>RuleHeader:1>DescriptionHelper:2>#Comment:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#Comment"),
            String::from("#BackgroundLine"),
            String::from("#TagLine"),
            String::from("#ScenarioLine"),
            String::from("#RuleLine"),
            String::from("#Empty"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(24)
    }

    // GherkinDocument:0>Feature:3>Rule:1>Background:0>#BackgroundLine:0
    fn match_token_at_25(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_eof(context, &mut token)? {
            self.end_rule(context, RuleType::Background)?;
            self.end_rule(context, RuleType::Rule)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(41);
        }
        if self.match_empty(context, &mut token)? {
            self.build(context, token)?;
            return Ok(25);
        }
        if self.match_comment(context, &mut token)? {
            self.build(context, token)?;
            return Ok(27);
        }
        if self.match_step_line(context, &mut token)? {
            self.start_rule(context, RuleType::Step)?;
            self.build(context, token)?;
            return Ok(28);
        }
        if self.match_tag_line(context, &mut token)? {
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(30);
        }
        if self.match_scenario_line(context, &mut token)? {
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(31);
        }
        if self.match_rule_line(context, &mut token)? {
            self.end_rule(context, RuleType::Background)?;
            self.end_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::RuleHeader)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_other(context, &mut token)? {
            self.start_rule(context, RuleType::Description)?;
            self.build(context, token)?;
            return Ok(26);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 25 - GherkinDocument:0>Feature:3>Rule:1>Background:0>#BackgroundLine:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#Empty"),
            String::from("#Comment"),
            String::from("#StepLine"),
            String::from("#TagLine"),
            String::from("#ScenarioLine"),
            String::from("#RuleLine"),
            String::from("#Other"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(25)
    }

    // GherkinDocument:0>Feature:3>Rule:1>Background:1>DescriptionHelper:1>Description:0>#Other:0
    fn match_token_at_26(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_eof(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::Background)?;
            self.end_rule(context, RuleType::Rule)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(41);
        }
        if self.match_comment(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.build(context, token)?;
            return Ok(27);
        }
        if self.match_step_line(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.start_rule(context, RuleType::Step)?;
            self.build(context, token)?;
            return Ok(28);
        }
        if self.match_tag_line(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(30);
        }
        if self.match_scenario_line(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(31);
        }
        if self.match_rule_line(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::Background)?;
            self.end_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::RuleHeader)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_other(context, &mut token)? {
            self.build(context, token)?;
            return Ok(26);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 26 - GherkinDocument:0>Feature:3>Rule:1>Background:1>DescriptionHelper:1>Description:0>#Other:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#Comment"),
            String::from("#StepLine"),
            String::from("#TagLine"),
            String::from("#ScenarioLine"),
            String::from("#RuleLine"),
            String::from("#Other"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(26)
    }

    // GherkinDocument:0>Feature:3>Rule:1>Background:1>DescriptionHelper:2>#Comment:0
    fn match_token_at_27(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_eof(context, &mut token)? {
            self.end_rule(context, RuleType::Background)?;
            self.end_rule(context, RuleType::Rule)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(41);
        }
        if self.match_comment(context, &mut token)? {
            self.build(context, token)?;
            return Ok(27);
        }
        if self.match_step_line(context, &mut token)? {
            self.start_rule(context, RuleType::Step)?;
            self.build(context, token)?;
            return Ok(28);
        }
        if self.match_tag_line(context, &mut token)? {
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(30);
        }
        if self.match_scenario_line(context, &mut token)? {
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(31);
        }
        if self.match_rule_line(context, &mut token)? {
            self.end_rule(context, RuleType::Background)?;
            self.end_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::RuleHeader)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_empty(context, &mut token)? {
            self.build(context, token)?;
            return Ok(27);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 27 - GherkinDocument:0>Feature:3>Rule:1>Background:1>DescriptionHelper:2>#Comment:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#Comment"),
            String::from("#StepLine"),
            String::from("#TagLine"),
            String::from("#ScenarioLine"),
            String::from("#RuleLine"),
            String::from("#Empty"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(27)
    }

    // GherkinDocument:0>Feature:3>Rule:1>Background:2>Step:0>#StepLine:0
    fn match_token_at_28(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_eof(context, &mut token)? {
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Background)?;
            self.end_rule(context, RuleType::Rule)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(41);
        }
        if self.match_table_row(context, &mut token)? {
            self.start_rule(context, RuleType::DataTable)?;
            self.build(context, token)?;
            return Ok(29);
        }
        if self.match_doc_string_separator(context, &mut token)? {
            self.start_rule(context, RuleType::DocString)?;
            self.build(context, token)?;
            return Ok(44);
        }
        if self.match_step_line(context, &mut token)? {
            self.end_rule(context, RuleType::Step)?;
            self.start_rule(context, RuleType::Step)?;
            self.build(context, token)?;
            return Ok(28);
        }
        if self.match_tag_line(context, &mut token)? {
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(30);
        }
        if self.match_scenario_line(context, &mut token)? {
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(31);
        }
        if self.match_rule_line(context, &mut token)? {
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Background)?;
            self.end_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::RuleHeader)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_comment(context, &mut token)? {
            self.build(context, token)?;
            return Ok(28);
        }
        if self.match_empty(context, &mut token)? {
            self.build(context, token)?;
            return Ok(28);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 28 - GherkinDocument:0>Feature:3>Rule:1>Background:2>Step:0>#StepLine:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#TableRow"),
            String::from("#DocStringSeparator"),
            String::from("#StepLine"),
            String::from("#TagLine"),
            String::from("#ScenarioLine"),
            String::from("#RuleLine"),
            String::from("#Comment"),
            String::from("#Empty"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(28)
    }

    // GherkinDocument:0>Feature:3>Rule:1>Background:2>Step:1>StepArg:0>__alt0:0>DataTable:0>#TableRow:0
    fn match_token_at_29(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_eof(context, &mut token)? {
            self.end_rule(context, RuleType::DataTable)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Background)?;
            self.end_rule(context, RuleType::Rule)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(41);
        }
        if self.match_table_row(context, &mut token)? {
            self.build(context, token)?;
            return Ok(29);
        }
        if self.match_step_line(context, &mut token)? {
            self.end_rule(context, RuleType::DataTable)?;
            self.end_rule(context, RuleType::Step)?;
            self.start_rule(context, RuleType::Step)?;
            self.build(context, token)?;
            return Ok(28);
        }
        if self.match_tag_line(context, &mut token)? {
            self.end_rule(context, RuleType::DataTable)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(30);
        }
        if self.match_scenario_line(context, &mut token)? {
            self.end_rule(context, RuleType::DataTable)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(31);
        }
        if self.match_rule_line(context, &mut token)? {
            self.end_rule(context, RuleType::DataTable)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Background)?;
            self.end_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::RuleHeader)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_comment(context, &mut token)? {
            self.build(context, token)?;
            return Ok(29);
        }
        if self.match_empty(context, &mut token)? {
            self.build(context, token)?;
            return Ok(29);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 29 - GherkinDocument:0>Feature:3>Rule:1>Background:2>Step:1>StepArg:0>__alt0:0>DataTable:0>#TableRow:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#TableRow"),
            String::from("#StepLine"),
            String::from("#TagLine"),
            String::from("#ScenarioLine"),
            String::from("#RuleLine"),
            String::from("#Comment"),
            String::from("#Empty"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(29)
    }

    // GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:0>Tags:0>#TagLine:0
    fn match_token_at_30(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_tag_line(context, &mut token)? {
            self.build(context, token)?;
            return Ok(30);
        }
        if self.match_scenario_line(context, &mut token)? {
            self.end_rule(context, RuleType::Tags)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(31);
        }
        if self.match_comment(context, &mut token)? {
            self.build(context, token)?;
            return Ok(30);
        }
        if self.match_empty(context, &mut token)? {
            self.build(context, token)?;
            return Ok(30);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 30 - GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:0>Tags:0>#TagLine:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#TagLine"),
            String::from("#ScenarioLine"),
            String::from("#Comment"),
            String::from("#Empty"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(30)
    }

    // GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:0>#ScenarioLine:0
    fn match_token_at_31(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_eof(context, &mut token)? {
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Rule)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(41);
        }
        if self.match_empty(context, &mut token)? {
            self.build(context, token)?;
            return Ok(31);
        }
        if self.match_comment(context, &mut token)? {
            self.build(context, token)?;
            return Ok(33);
        }
        if self.match_step_line(context, &mut token)? {
            self.start_rule(context, RuleType::Step)?;
            self.build(context, token)?;
            return Ok(34);
        }
        let match_tag_line_with_lookahead =
            { self.match_tag_line(context, &mut token)? && self.lookahead_0(context, &token) };
        if match_tag_line_with_lookahead {
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(36);
        }
        if self.match_tag_line(context, &mut token)? {
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(30);
        }
        if self.match_examples_line(context, &mut token)? {
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Examples)?;
            self.build(context, token)?;
            return Ok(37);
        }
        if self.match_scenario_line(context, &mut token)? {
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(31);
        }
        if self.match_rule_line(context, &mut token)? {
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::RuleHeader)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_other(context, &mut token)? {
            self.start_rule(context, RuleType::Description)?;
            self.build(context, token)?;
            return Ok(32);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 31 - GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:0>#ScenarioLine:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#Empty"),
            String::from("#Comment"),
            String::from("#StepLine"),
            String::from("#TagLine"),
            String::from("#ExamplesLine"),
            String::from("#ScenarioLine"),
            String::from("#RuleLine"),
            String::from("#Other"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(31)
    }

    // GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:1>DescriptionHelper:1>Description:0>#Other:0
    fn match_token_at_32(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_eof(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Rule)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(41);
        }
        if self.match_comment(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.build(context, token)?;
            return Ok(33);
        }
        if self.match_step_line(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.start_rule(context, RuleType::Step)?;
            self.build(context, token)?;
            return Ok(34);
        }
        let match_tag_line_with_lookahead =
            { self.match_tag_line(context, &mut token)? && self.lookahead_0(context, &token) };
        if match_tag_line_with_lookahead {
            self.end_rule(context, RuleType::Description)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(36);
        }
        if self.match_tag_line(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(30);
        }
        if self.match_examples_line(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Examples)?;
            self.build(context, token)?;
            return Ok(37);
        }
        if self.match_scenario_line(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(31);
        }
        if self.match_rule_line(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::RuleHeader)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_other(context, &mut token)? {
            self.build(context, token)?;
            return Ok(32);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 32 - GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:1>DescriptionHelper:1>Description:0>#Other:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#Comment"),
            String::from("#StepLine"),
            String::from("#TagLine"),
            String::from("#ExamplesLine"),
            String::from("#ScenarioLine"),
            String::from("#RuleLine"),
            String::from("#Other"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(32)
    }

    // GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:1>DescriptionHelper:2>#Comment:0
    fn match_token_at_33(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_eof(context, &mut token)? {
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Rule)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(41);
        }
        if self.match_comment(context, &mut token)? {
            self.build(context, token)?;
            return Ok(33);
        }
        if self.match_step_line(context, &mut token)? {
            self.start_rule(context, RuleType::Step)?;
            self.build(context, token)?;
            return Ok(34);
        }
        let match_tag_line_with_lookahead =
            { self.match_tag_line(context, &mut token)? && self.lookahead_0(context, &token) };
        if match_tag_line_with_lookahead {
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(36);
        }
        if self.match_tag_line(context, &mut token)? {
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(30);
        }
        if self.match_examples_line(context, &mut token)? {
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Examples)?;
            self.build(context, token)?;
            return Ok(37);
        }
        if self.match_scenario_line(context, &mut token)? {
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(31);
        }
        if self.match_rule_line(context, &mut token)? {
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::RuleHeader)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_empty(context, &mut token)? {
            self.build(context, token)?;
            return Ok(33);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 33 - GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:1>DescriptionHelper:2>#Comment:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#Comment"),
            String::from("#StepLine"),
            String::from("#TagLine"),
            String::from("#ExamplesLine"),
            String::from("#ScenarioLine"),
            String::from("#RuleLine"),
            String::from("#Empty"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(33)
    }

    // GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:2>Step:0>#StepLine:0
    fn match_token_at_34(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_eof(context, &mut token)? {
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Rule)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(41);
        }
        if self.match_table_row(context, &mut token)? {
            self.start_rule(context, RuleType::DataTable)?;
            self.build(context, token)?;
            return Ok(35);
        }
        if self.match_doc_string_separator(context, &mut token)? {
            self.start_rule(context, RuleType::DocString)?;
            self.build(context, token)?;
            return Ok(42);
        }
        if self.match_step_line(context, &mut token)? {
            self.end_rule(context, RuleType::Step)?;
            self.start_rule(context, RuleType::Step)?;
            self.build(context, token)?;
            return Ok(34);
        }
        let match_tag_line_with_lookahead =
            { self.match_tag_line(context, &mut token)? && self.lookahead_0(context, &token) };
        if match_tag_line_with_lookahead {
            self.end_rule(context, RuleType::Step)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(36);
        }
        if self.match_tag_line(context, &mut token)? {
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(30);
        }
        if self.match_examples_line(context, &mut token)? {
            self.end_rule(context, RuleType::Step)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Examples)?;
            self.build(context, token)?;
            return Ok(37);
        }
        if self.match_scenario_line(context, &mut token)? {
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(31);
        }
        if self.match_rule_line(context, &mut token)? {
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::RuleHeader)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_comment(context, &mut token)? {
            self.build(context, token)?;
            return Ok(34);
        }
        if self.match_empty(context, &mut token)? {
            self.build(context, token)?;
            return Ok(34);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 34 - GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:2>Step:0>#StepLine:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#TableRow"),
            String::from("#DocStringSeparator"),
            String::from("#StepLine"),
            String::from("#TagLine"),
            String::from("#ExamplesLine"),
            String::from("#ScenarioLine"),
            String::from("#RuleLine"),
            String::from("#Comment"),
            String::from("#Empty"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(34)
    }

    // GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:2>Step:1>StepArg:0>__alt0:0>DataTable:0>#TableRow:0
    fn match_token_at_35(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_eof(context, &mut token)? {
            self.end_rule(context, RuleType::DataTable)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Rule)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(41);
        }
        if self.match_table_row(context, &mut token)? {
            self.build(context, token)?;
            return Ok(35);
        }
        if self.match_step_line(context, &mut token)? {
            self.end_rule(context, RuleType::DataTable)?;
            self.end_rule(context, RuleType::Step)?;
            self.start_rule(context, RuleType::Step)?;
            self.build(context, token)?;
            return Ok(34);
        }
        let match_tag_line_with_lookahead =
            { self.match_tag_line(context, &mut token)? && self.lookahead_0(context, &token) };
        if match_tag_line_with_lookahead {
            self.end_rule(context, RuleType::DataTable)?;
            self.end_rule(context, RuleType::Step)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(36);
        }
        if self.match_tag_line(context, &mut token)? {
            self.end_rule(context, RuleType::DataTable)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(30);
        }
        if self.match_examples_line(context, &mut token)? {
            self.end_rule(context, RuleType::DataTable)?;
            self.end_rule(context, RuleType::Step)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Examples)?;
            self.build(context, token)?;
            return Ok(37);
        }
        if self.match_scenario_line(context, &mut token)? {
            self.end_rule(context, RuleType::DataTable)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(31);
        }
        if self.match_rule_line(context, &mut token)? {
            self.end_rule(context, RuleType::DataTable)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::RuleHeader)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_comment(context, &mut token)? {
            self.build(context, token)?;
            return Ok(35);
        }
        if self.match_empty(context, &mut token)? {
            self.build(context, token)?;
            return Ok(35);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 35 - GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:2>Step:1>StepArg:0>__alt0:0>DataTable:0>#TableRow:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#TableRow"),
            String::from("#StepLine"),
            String::from("#TagLine"),
            String::from("#ExamplesLine"),
            String::from("#ScenarioLine"),
            String::from("#RuleLine"),
            String::from("#Comment"),
            String::from("#Empty"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(35)
    }

    // GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:3>ExamplesDefinition:0>Tags:0>#TagLine:0
    fn match_token_at_36(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_tag_line(context, &mut token)? {
            self.build(context, token)?;
            return Ok(36);
        }
        if self.match_examples_line(context, &mut token)? {
            self.end_rule(context, RuleType::Tags)?;
            self.start_rule(context, RuleType::Examples)?;
            self.build(context, token)?;
            return Ok(37);
        }
        if self.match_comment(context, &mut token)? {
            self.build(context, token)?;
            return Ok(36);
        }
        if self.match_empty(context, &mut token)? {
            self.build(context, token)?;
            return Ok(36);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 36 - GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:3>ExamplesDefinition:0>Tags:0>#TagLine:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#TagLine"),
            String::from("#ExamplesLine"),
            String::from("#Comment"),
            String::from("#Empty"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(36)
    }

    // GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:3>ExamplesDefinition:1>Examples:0>#ExamplesLine:0
    fn match_token_at_37(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_eof(context, &mut token)? {
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Rule)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(41);
        }
        if self.match_empty(context, &mut token)? {
            self.build(context, token)?;
            return Ok(37);
        }
        if self.match_comment(context, &mut token)? {
            self.build(context, token)?;
            return Ok(39);
        }
        if self.match_table_row(context, &mut token)? {
            self.start_rule(context, RuleType::ExamplesTable)?;
            self.build(context, token)?;
            return Ok(40);
        }
        let match_tag_line_with_lookahead =
            { self.match_tag_line(context, &mut token)? && self.lookahead_0(context, &token) };
        if match_tag_line_with_lookahead {
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(36);
        }
        if self.match_tag_line(context, &mut token)? {
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(30);
        }
        if self.match_examples_line(context, &mut token)? {
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Examples)?;
            self.build(context, token)?;
            return Ok(37);
        }
        if self.match_scenario_line(context, &mut token)? {
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(31);
        }
        if self.match_rule_line(context, &mut token)? {
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::RuleHeader)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_other(context, &mut token)? {
            self.start_rule(context, RuleType::Description)?;
            self.build(context, token)?;
            return Ok(38);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 37 - GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:3>ExamplesDefinition:1>Examples:0>#ExamplesLine:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#Empty"),
            String::from("#Comment"),
            String::from("#TableRow"),
            String::from("#TagLine"),
            String::from("#ExamplesLine"),
            String::from("#ScenarioLine"),
            String::from("#RuleLine"),
            String::from("#Other"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(37)
    }

    // GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:3>ExamplesDefinition:1>Examples:1>DescriptionHelper:1>Description:0>#Other:0
    fn match_token_at_38(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_eof(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Rule)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(41);
        }
        if self.match_comment(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.build(context, token)?;
            return Ok(39);
        }
        if self.match_table_row(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.start_rule(context, RuleType::ExamplesTable)?;
            self.build(context, token)?;
            return Ok(40);
        }
        let match_tag_line_with_lookahead =
            { self.match_tag_line(context, &mut token)? && self.lookahead_0(context, &token) };
        if match_tag_line_with_lookahead {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(36);
        }
        if self.match_tag_line(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(30);
        }
        if self.match_examples_line(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Examples)?;
            self.build(context, token)?;
            return Ok(37);
        }
        if self.match_scenario_line(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(31);
        }
        if self.match_rule_line(context, &mut token)? {
            self.end_rule(context, RuleType::Description)?;
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::RuleHeader)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_other(context, &mut token)? {
            self.build(context, token)?;
            return Ok(38);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 38 - GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:3>ExamplesDefinition:1>Examples:1>DescriptionHelper:1>Description:0>#Other:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#Comment"),
            String::from("#TableRow"),
            String::from("#TagLine"),
            String::from("#ExamplesLine"),
            String::from("#ScenarioLine"),
            String::from("#RuleLine"),
            String::from("#Other"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(38)
    }

    // GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:3>ExamplesDefinition:1>Examples:1>DescriptionHelper:2>#Comment:0
    fn match_token_at_39(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_eof(context, &mut token)? {
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Rule)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(41);
        }
        if self.match_comment(context, &mut token)? {
            self.build(context, token)?;
            return Ok(39);
        }
        if self.match_table_row(context, &mut token)? {
            self.start_rule(context, RuleType::ExamplesTable)?;
            self.build(context, token)?;
            return Ok(40);
        }
        let match_tag_line_with_lookahead =
            { self.match_tag_line(context, &mut token)? && self.lookahead_0(context, &token) };
        if match_tag_line_with_lookahead {
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(36);
        }
        if self.match_tag_line(context, &mut token)? {
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(30);
        }
        if self.match_examples_line(context, &mut token)? {
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Examples)?;
            self.build(context, token)?;
            return Ok(37);
        }
        if self.match_scenario_line(context, &mut token)? {
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(31);
        }
        if self.match_rule_line(context, &mut token)? {
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::RuleHeader)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_empty(context, &mut token)? {
            self.build(context, token)?;
            return Ok(39);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 39 - GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:3>ExamplesDefinition:1>Examples:1>DescriptionHelper:2>#Comment:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#Comment"),
            String::from("#TableRow"),
            String::from("#TagLine"),
            String::from("#ExamplesLine"),
            String::from("#ScenarioLine"),
            String::from("#RuleLine"),
            String::from("#Empty"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(39)
    }

    // GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:3>ExamplesDefinition:1>Examples:2>ExamplesTable:0>#TableRow:0
    fn match_token_at_40(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_eof(context, &mut token)? {
            self.end_rule(context, RuleType::ExamplesTable)?;
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Rule)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(41);
        }
        if self.match_table_row(context, &mut token)? {
            self.build(context, token)?;
            return Ok(40);
        }
        let match_tag_line_with_lookahead =
            { self.match_tag_line(context, &mut token)? && self.lookahead_0(context, &token) };
        if match_tag_line_with_lookahead {
            self.end_rule(context, RuleType::ExamplesTable)?;
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(36);
        }
        if self.match_tag_line(context, &mut token)? {
            self.end_rule(context, RuleType::ExamplesTable)?;
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(30);
        }
        if self.match_examples_line(context, &mut token)? {
            self.end_rule(context, RuleType::ExamplesTable)?;
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Examples)?;
            self.build(context, token)?;
            return Ok(37);
        }
        if self.match_scenario_line(context, &mut token)? {
            self.end_rule(context, RuleType::ExamplesTable)?;
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(31);
        }
        if self.match_rule_line(context, &mut token)? {
            self.end_rule(context, RuleType::ExamplesTable)?;
            self.end_rule(context, RuleType::Examples)?;
            self.end_rule(context, RuleType::ExamplesDefinition)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::RuleHeader)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_comment(context, &mut token)? {
            self.build(context, token)?;
            return Ok(40);
        }
        if self.match_empty(context, &mut token)? {
            self.build(context, token)?;
            return Ok(40);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 40 - GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:3>ExamplesDefinition:1>Examples:2>ExamplesTable:0>#TableRow:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#TableRow"),
            String::from("#TagLine"),
            String::from("#ExamplesLine"),
            String::from("#ScenarioLine"),
            String::from("#RuleLine"),
            String::from("#Comment"),
            String::from("#Empty"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(40)
    }

    // GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:2>Step:1>StepArg:0>__alt0:1>DocString:0>#DocStringSeparator:0
    fn match_token_at_42(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_doc_string_separator(context, &mut token)? {
            self.build(context, token)?;
            return Ok(43);
        }
        if self.match_other(context, &mut token)? {
            self.build(context, token)?;
            return Ok(42);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 42 - GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:2>Step:1>StepArg:0>__alt0:1>DocString:0>#DocStringSeparator:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#DocStringSeparator"),
            String::from("#Other"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(42)
    }

    // GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:2>Step:1>StepArg:0>__alt0:1>DocString:2>#DocStringSeparator:0
    fn match_token_at_43(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_eof(context, &mut token)? {
            self.end_rule(context, RuleType::DocString)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Rule)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(41);
        }
        if self.match_step_line(context, &mut token)? {
            self.end_rule(context, RuleType::DocString)?;
            self.end_rule(context, RuleType::Step)?;
            self.start_rule(context, RuleType::Step)?;
            self.build(context, token)?;
            return Ok(34);
        }
        let match_tag_line_with_lookahead =
            { self.match_tag_line(context, &mut token)? && self.lookahead_0(context, &token) };
        if match_tag_line_with_lookahead {
            self.end_rule(context, RuleType::DocString)?;
            self.end_rule(context, RuleType::Step)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(36);
        }
        if self.match_tag_line(context, &mut token)? {
            self.end_rule(context, RuleType::DocString)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(30);
        }
        if self.match_examples_line(context, &mut token)? {
            self.end_rule(context, RuleType::DocString)?;
            self.end_rule(context, RuleType::Step)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Examples)?;
            self.build(context, token)?;
            return Ok(37);
        }
        if self.match_scenario_line(context, &mut token)? {
            self.end_rule(context, RuleType::DocString)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(31);
        }
        if self.match_rule_line(context, &mut token)? {
            self.end_rule(context, RuleType::DocString)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::RuleHeader)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_comment(context, &mut token)? {
            self.build(context, token)?;
            return Ok(43);
        }
        if self.match_empty(context, &mut token)? {
            self.build(context, token)?;
            return Ok(43);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 43 - GherkinDocument:0>Feature:3>Rule:2>ScenarioDefinition:1>Scenario:2>Step:1>StepArg:0>__alt0:1>DocString:2>#DocStringSeparator:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#StepLine"),
            String::from("#TagLine"),
            String::from("#ExamplesLine"),
            String::from("#ScenarioLine"),
            String::from("#RuleLine"),
            String::from("#Comment"),
            String::from("#Empty"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(43)
    }

    // GherkinDocument:0>Feature:3>Rule:1>Background:2>Step:1>StepArg:0>__alt0:1>DocString:0>#DocStringSeparator:0
    fn match_token_at_44(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_doc_string_separator(context, &mut token)? {
            self.build(context, token)?;
            return Ok(45);
        }
        if self.match_other(context, &mut token)? {
            self.build(context, token)?;
            return Ok(44);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 44 - GherkinDocument:0>Feature:3>Rule:1>Background:2>Step:1>StepArg:0>__alt0:1>DocString:0>#DocStringSeparator:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#DocStringSeparator"),
            String::from("#Other"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(44)
    }

    // GherkinDocument:0>Feature:3>Rule:1>Background:2>Step:1>StepArg:0>__alt0:1>DocString:2>#DocStringSeparator:0
    fn match_token_at_45(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_eof(context, &mut token)? {
            self.end_rule(context, RuleType::DocString)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Background)?;
            self.end_rule(context, RuleType::Rule)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(41);
        }
        if self.match_step_line(context, &mut token)? {
            self.end_rule(context, RuleType::DocString)?;
            self.end_rule(context, RuleType::Step)?;
            self.start_rule(context, RuleType::Step)?;
            self.build(context, token)?;
            return Ok(28);
        }
        if self.match_tag_line(context, &mut token)? {
            self.end_rule(context, RuleType::DocString)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(30);
        }
        if self.match_scenario_line(context, &mut token)? {
            self.end_rule(context, RuleType::DocString)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(31);
        }
        if self.match_rule_line(context, &mut token)? {
            self.end_rule(context, RuleType::DocString)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Background)?;
            self.end_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::RuleHeader)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_comment(context, &mut token)? {
            self.build(context, token)?;
            return Ok(45);
        }
        if self.match_empty(context, &mut token)? {
            self.build(context, token)?;
            return Ok(45);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 45 - GherkinDocument:0>Feature:3>Rule:1>Background:2>Step:1>StepArg:0>__alt0:1>DocString:2>#DocStringSeparator:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#StepLine"),
            String::from("#TagLine"),
            String::from("#ScenarioLine"),
            String::from("#RuleLine"),
            String::from("#Comment"),
            String::from("#Empty"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(45)
    }

    // GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:2>Step:1>StepArg:0>__alt0:1>DocString:0>#DocStringSeparator:0
    fn match_token_at_46(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_doc_string_separator(context, &mut token)? {
            self.build(context, token)?;
            return Ok(47);
        }
        if self.match_other(context, &mut token)? {
            self.build(context, token)?;
            return Ok(46);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 46 - GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:2>Step:1>StepArg:0>__alt0:1>DocString:0>#DocStringSeparator:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#DocStringSeparator"),
            String::from("#Other"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(46)
    }

    // GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:2>Step:1>StepArg:0>__alt0:1>DocString:2>#DocStringSeparator:0
    fn match_token_at_47(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_eof(context, &mut token)? {
            self.end_rule(context, RuleType::DocString)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(41);
        }
        if self.match_step_line(context, &mut token)? {
            self.end_rule(context, RuleType::DocString)?;
            self.end_rule(context, RuleType::Step)?;
            self.start_rule(context, RuleType::Step)?;
            self.build(context, token)?;
            return Ok(15);
        }
        let match_tag_line_with_lookahead =
            { self.match_tag_line(context, &mut token)? && self.lookahead_0(context, &token) };
        if match_tag_line_with_lookahead {
            self.end_rule(context, RuleType::DocString)?;
            self.end_rule(context, RuleType::Step)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(17);
        }
        if self.match_tag_line(context, &mut token)? {
            self.end_rule(context, RuleType::DocString)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_examples_line(context, &mut token)? {
            self.end_rule(context, RuleType::DocString)?;
            self.end_rule(context, RuleType::Step)?;
            self.start_rule(context, RuleType::ExamplesDefinition)?;
            self.start_rule(context, RuleType::Examples)?;
            self.build(context, token)?;
            return Ok(18);
        }
        if self.match_scenario_line(context, &mut token)? {
            self.end_rule(context, RuleType::DocString)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_rule_line(context, &mut token)? {
            self.end_rule(context, RuleType::DocString)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Scenario)?;
            self.end_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::RuleHeader)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_comment(context, &mut token)? {
            self.build(context, token)?;
            return Ok(47);
        }
        if self.match_empty(context, &mut token)? {
            self.build(context, token)?;
            return Ok(47);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 47 - GherkinDocument:0>Feature:2>ScenarioDefinition:1>Scenario:2>Step:1>StepArg:0>__alt0:1>DocString:2>#DocStringSeparator:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#StepLine"),
            String::from("#TagLine"),
            String::from("#ExamplesLine"),
            String::from("#ScenarioLine"),
            String::from("#RuleLine"),
            String::from("#Comment"),
            String::from("#Empty"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(47)
    }

    // GherkinDocument:0>Feature:1>Background:2>Step:1>StepArg:0>__alt0:1>DocString:0>#DocStringSeparator:0
    fn match_token_at_48(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_doc_string_separator(context, &mut token)? {
            self.build(context, token)?;
            return Ok(49);
        }
        if self.match_other(context, &mut token)? {
            self.build(context, token)?;
            return Ok(48);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 48 - GherkinDocument:0>Feature:1>Background:2>Step:1>StepArg:0>__alt0:1>DocString:0>#DocStringSeparator:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#DocStringSeparator"),
            String::from("#Other"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(48)
    }

    // GherkinDocument:0>Feature:1>Background:2>Step:1>StepArg:0>__alt0:1>DocString:2>#DocStringSeparator:0
    fn match_token_at_49(
        &mut self,
        mut token: Token,
        context: &mut ParserContext<'_>,
    ) -> Result<u32> {
        if self.match_eof(context, &mut token)? {
            self.end_rule(context, RuleType::DocString)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Background)?;
            self.end_rule(context, RuleType::Feature)?;
            self.build(context, token)?;
            return Ok(41);
        }
        if self.match_step_line(context, &mut token)? {
            self.end_rule(context, RuleType::DocString)?;
            self.end_rule(context, RuleType::Step)?;
            self.start_rule(context, RuleType::Step)?;
            self.build(context, token)?;
            return Ok(9);
        }
        if self.match_tag_line(context, &mut token)? {
            self.end_rule(context, RuleType::DocString)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Tags)?;
            self.build(context, token)?;
            return Ok(11);
        }
        if self.match_scenario_line(context, &mut token)? {
            self.end_rule(context, RuleType::DocString)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::ScenarioDefinition)?;
            self.start_rule(context, RuleType::Scenario)?;
            self.build(context, token)?;
            return Ok(12);
        }
        if self.match_rule_line(context, &mut token)? {
            self.end_rule(context, RuleType::DocString)?;
            self.end_rule(context, RuleType::Step)?;
            self.end_rule(context, RuleType::Background)?;
            self.start_rule(context, RuleType::Rule)?;
            self.start_rule(context, RuleType::RuleHeader)?;
            self.build(context, token)?;
            return Ok(22);
        }
        if self.match_comment(context, &mut token)? {
            self.build(context, token)?;
            return Ok(49);
        }
        if self.match_empty(context, &mut token)? {
            self.build(context, token)?;
            return Ok(49);
        }

        #[rustfmt::skip] // because the generated lengths differ
        let state_comment = String::from("State: 49 - GherkinDocument:0>Feature:1>Background:2>Step:1>StepArg:0>__alt0:1>DocString:2>#DocStringSeparator:0");

        token.detach();

        #[rustfmt::skip] // because the generated lengths differ
        let expected_tokens: Vec<String> = vec![
            String::from("#EOF"),
            String::from("#StepLine"),
            String::from("#TagLine"),
            String::from("#ScenarioLine"),
            String::from("#RuleLine"),
            String::from("#Comment"),
            String::from("#Empty"),
        ];

        let token_location = token.location.expect("token location");

        let error = if token.is_eof() {
            Error::UnexpectedEof {
                location: token_location,
                state_comment,
                expected_tokens,
            }
        } else {
            let location = if token_location.column > 1 {
                token_location
            } else {
                let token_line = token.line.as_ref().expect("token line");
                let line = token_location.line;
                let column = token_line.indent() + 1;
                Location::new(line, column)
            };

            Error::UnexpectedToken {
                location,
                state_comment,
                received_token: Box::new(token),
                expected_tokens,
            }
        };

        if self.stop_at_first_error {
            return Err(error);
        }

        self.add_error(context, error);
        Ok(49)
    }

    #[allow(clippy::nonminimal_bool)] // simplifies the parser template
    #[rustfmt::skip] // simplifies the parser template
    fn lookahead_0(&mut self, context: &mut ParserContext<'_>, current_token: &Token) -> bool {
        current_token.detach();
        let mut token: Token;
        let mut queue: VecDeque<Token> = VecDeque::new();
        let mut found_match = false;
        loop {
            token = self.read_token(context).expect("read next token");
            token.detach();
            queue.push_back(token.clone());

            if false
                || self.match_examples_line(context, &mut token) .unwrap_or(false)
            {
                found_match = true;
                break;
            }

             if true
                 && !self.match_empty(context, &mut token) .unwrap_or(true)
                 && !self.match_comment(context, &mut token) .unwrap_or(true)
                 && !self.match_tag_line(context, &mut token) .unwrap_or(true)
             {
                 break;
             }
        }

        context.token_queue.extend(queue);

        found_match
    }
}

pub trait Builder {
    type BuilderResult;

    fn build(&mut self, token: Token) -> Result<()>;
    fn start_rule(&mut self, rule_type: RuleType) -> Result<()>;
    fn end_rule(&mut self, rule_type: RuleType) -> Result<()>;
    fn get_result(&mut self) -> Self::BuilderResult;
    fn reset(&mut self);
}

pub trait TokenScan {
    fn next(&mut self) -> Result<Token>;
}

pub trait TokenMatch {
    fn match_eof(&mut self, token: &mut Token) -> Result<bool>;
    fn match_empty(&mut self, token: &mut Token) -> Result<bool>;
    fn match_comment(&mut self, token: &mut Token) -> Result<bool>;
    fn match_tag_line(&mut self, token: &mut Token) -> Result<bool>;
    fn match_feature_line(&mut self, token: &mut Token) -> Result<bool>;
    fn match_rule_line(&mut self, token: &mut Token) -> Result<bool>;
    fn match_background_line(&mut self, token: &mut Token) -> Result<bool>;
    fn match_scenario_line(&mut self, token: &mut Token) -> Result<bool>;
    fn match_examples_line(&mut self, token: &mut Token) -> Result<bool>;
    fn match_step_line(&mut self, token: &mut Token) -> Result<bool>;
    fn match_doc_string_separator(&mut self, token: &mut Token) -> Result<bool>;
    fn match_table_row(&mut self, token: &mut Token) -> Result<bool>;
    fn match_language(&mut self, token: &mut Token) -> Result<bool>;
    fn match_other(&mut self, token: &mut Token) -> Result<bool>;
    fn reset(&mut self);
}

pub trait GherkinDialectProvide {
    fn get_default_dialect(&self) -> Result<Arc<GherkinDialect>>;

    fn get_dialect(&self, language: &str, location: Location) -> Result<Arc<GherkinDialect>>;

    fn get_languages(&self) -> Vec<&String>;
}
